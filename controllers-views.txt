https://github.com/LinkedInLearning/ruby-on-rails-controllers-and-views-2498312

You can also run rails lil:import anytime you want to get the database data in the same state as mine.

USEFUL CONTROLLER FEATURES

Store data in cookies

In this chapter, we'll explore several useful controller features, beginning with learning how cookies work in Ruby on rails. HTML is stateless. Each request from the browser to the web server is distinct. And the state of the user's interaction with the web application and information related to previous requests is not automatically preserved. 

Cookies are an efficient way for web application to keep track of data across requests. When responding to a request, the web server can send data to the browser for it to store in a cookie on the user's local computer. Then the browser will send that cookie data back with each and every future request. 

You should set cookies and retrieve their data inside your controllers, not in the views or in the models. Setting cookies is like working with a standard Ruby hash. You can set a cookie by setting a key and value in cookies. 

Here I'm setting a cookie with the key, username, and a value of J Smith. This is the simplest and most common usage, but you can include other options like an expiration time. Behind the scenes, Rails will prepare to send this data in the response to the current request. The browser will then send that data back with all future requests. 

And you can read cookies also like you're working with a standard Ruby hash. Here I'm reading the value stored for the key, username, and I'm assigning it to an instance variable. 

Cookies have some limitations to keep in mind. First they have a maximum data size of four kilobytes, which is about 4,000 characters. They're designed to store small amounts of data. And that's good because the cookie data is send with every request, even if the web server won't make use of it. Never store instances of models in your cookies. They're usually too large and their data may become outdated. Cookies also reside on the user's computer. You should not assume that they're secret. They can be read, deleted, or altered. So don't store sensitive data in plain text. And always exercise caution when using data from cookies. 

Let's try an example. The exercise files include a Ruby on Rails application, which is based on the project we created in Ruby on Rails Essential Training, the task manager. I've added an access controller to allow us to simulate a login. It has several actions. And those are listed in the routes file too. You see, we have a resource for access. We also have some shortcuts that allow us to use login in order to get to access new and so on. 

Let's fire it up. From the root of our project, I'll type rails server. And then we'll go to Firefox and load localhost:3000. You can see, we get the list of tasks, but I'm interested in that login page, which is going to be /login or /accessnew. This is a simulated login form. When it's submitted, I do not intend to actually search for a username and password in the database. We're going to fake that part of the process, but it will submit to the create action. You can see, here's the new action that displays the form and the create action that will process the form. 

In the create action, let's just set a cookie to whatever username we were given as if it had existed in the database. So right here, we'll add cookies. And the key we'll use is username. We'll set it equal to the value of params:username. Be sure to make cookies plural. It's a container for many cookies. When the response is then send to the browser, it will include this cookie. The browser will save the cookie to send it with every future request. The create action ends with a redirect so that the next request will happen right away. 

It'll be routed to the menu action. In the menu action, we can read the value of the cookie. Let's do that and set it to the instance variable for username = cookies:username. From there, it will render the menu template. So let's use that instance value on the template. I'll just put some P tags here, and inside user, and then some ERB tags that will have username instance variable in it. Let's try it out. I'll come back over here to the form. 

And before I submit something, I'm also going to just open up the tools for Firefox, and go to Web Developer Tools, and choose the Network tab. 

That'll let me see the network activity. I'll put in a username. I don't need to put in a password since I'm not actually logging in. When I click login, you can see that it does display the value that we submitted that came back from the cookie. 

We can also look at the network information. And we'll see there's two requests. The first was the post request to access. And then we're redirected with the 302 redirect to the get request for menu. On the post request, if we click on cookies, we can see the response cookies, we scroll down here. Let me actually just pull this one up. Here's the username cookie with a value of kskoglund. That was send in the response back to the browser. Then the browser turned right around and submitted a new request. 

And let's look not at the response cookies this time, but the request cookies that it send. And you can see it included a cookie with the username kskoglund. We've successfully learned how to use cookies in our Ruby on Rails projects.

Store data in sessions

In this movie, we will learn how to store data in sessions, which are similar to cookies. 

With sessions, the web server sends a session identifier to the browser, which then saves it in a cookie. The browser sends that session identifier with every future request, just like with cookies, and Rails will automatically use the identifier to locate a storage area on the server, usually a file or a database, and make the data available to the web application. 

You can set and retrieve values in the session inside your controllers using the same hash notation that we used with cookies. Here, I'm defining the key language in the session and setting it to the string en. And then in future request, I can retrieve values from the session storage using the key. Here I'm using language. Behind the scenes, Rails will handle the data storage for you. 

Sessions do have some limitations. Retrieving the session file can add time to every request, especially if it uses the file system. The session files can accumulate and take up space. 1 million users means 1 million session files. It may be necessary to prune old session files occasionally. 

Session data is often stored on the server, but the session identifier is still stored on the user's computer. So that means that that session cookie can be deleted or stolen. Ruby on Rails offers several session storage options. In the file system, in a database table, in a cache like Redis, or in a cookie. 

In the past, Rails use file storage and database storage as defaults, and these remain popular options in other web development frameworks. However, the current default in Ruby on Rails is cookie storage. Cookie storage works a little bit differently than the other three. Rails will store session data in a cookie sent to the user's browser. This special cookie or super cookie will be encrypted to prevent reading its data, and cryptographically signed to prevent tampering. 

Unlike the other storage choices on the server side, there's no extra load time and no session files to accumulate or bloat our server. Of course, like all cookies, the data must be less than 4 K in size. But in most circumstances, that's enough. Cookie storage is a great choice, and I encourage you to use it. Rails manages the session cookie storage for us, including encrypting and signing the cookie data. 

When you create a new Rails app, Rails creates a master key file in the config directory and uses it for encrypting the credentials file. The credentials file includes the data used to encrypt and sign cookies. The encrypted credentials file can be shared as long as the master key is kept secret. Rail sets all of this up when a project is created. So you won't usually need to change anything. But you can edit the credentials with rails credentials:edit. 

Because they're encrypted, you'll also need to tell your text editor to wait so that you can edit a plain text version, and then let Rails encrypt your changes when the file is closed. Let's try working with them. In my Rails app, inside the config directory, you can see that I have credentials.yml.enc, which is some encrypted data in it. And then I have master key, which is just a simple password used to encrypt and decrypt those credentials. If you created your project from scratch, you will also have a master key file. But if you're using the course exercise files, you won't have it because it's automatically added to the gitignore file and isn't included in the repository. But that's okay. You don't need it for this example. 

I won't walk you through the editing process. Instead, let's try using the session. Let's go to access_controller, and let's add a user id to the session when a user logs in. So right here underneath the cookies, we'll put session, and the key for this will be user_id, and then I'm going to make up an ID 1483, and I'll just add a space here. The user id is a little more sensitive than the username. We're mostly storing that username for efficiency. We'll use the user id as an indication of whether the user is logged in or not. It's better not to put that in a cookie where it can be viewed or edited. So we're going to keep it in the session where it'll be safer. Then in our menu action, we can read that value from the session and set it to an instance variable. I'll have the instance variable user id, and I'll use session, and we'll have the key of user id. Let's save the file, and then let's go to our menu page, and let's use it here as well. I'll just put parentheses, and then some ERB tags to display the user id, just so we can see that we're reaching that value back. 

Let's try it out. Let's go here and launch our server. We'll open up Firefox. And we don't want the menu anymore. We want the login page. And I'm going to put in username kskoglund2, just so we can see a little bit of a difference. Click Log in. See the username there. And we see the made up ID, 1483. Now we know how to use both cookies and sessions to store data. I recommend that you use cookies for data that's not sensitive and should persist for weeks or even for months. Use sessions for everything else.

Messaging with the flash hash

In this movie, we will learn how to use a useful controller feature called the flash hash. The flash hash stores short messages in the session data. It's useful when a controller action will redirect to another action and we want to preserve a message so that the second action can retrieve it. It's for storing text strings, not Ruby objects or other data. Ruby on Rails keeps a message in the flash hash for exactly one additional request and then it automatically clears it. Of course you could store and retrieve text from the session yourself but the flash hash automates the process and makes it easier. This code demonstrates the primary use case for the flash hash. A controller action creates a new record and then redirects. The redirect will cause the browser to make a second request to a new controller action. And that second action doesn't automatically have information about what happened in the first action. But by putting a message in the flash hash, the message can be retrieved and used by the second action. In this case, the second action would probably show that success message in addition to the normal template that it renders. Flash hash messages are set by assigning a string to a key or a label. The most common label on flash messages is notice. You can choose any label you want though and you may decide to display them differently depending on the label. For example, the text flash notice could be colored blue. A flash error could be red. A flash alert could be orange and so on. If in doubt, stick with notice.

Log information to a file

In this movie, we will learn how to log custom information from controller actions. When a project is deployed, there are typically two sets of logs, server logs, and application logs. The web server will log basic data about each request as well as any errors that it encounters. The web server can see the request and the response but it does not know what happens inside the web application. The web application will log its activity in the application logs. It can provide useful information, especially for troubleshooting. The application logs are stored in the log directory. There's one log for each environment. When our project is running in development mode, we'll look for log output in the development log. You can configure the type of information that gets logged automatically and you can have different configurations for each environment. For example, you might set development to log a lot of information and production to log less. There are five log levels that you can choose from, debug, info, warn, error, and fatal. They log different amounts of information. In the first column, you can see that debug logs the most. It logs database queries, request and render details, deprecation, standard errors and fatal errors. Info is similar but without the database queries. Warn logs only errors and deprecation warnings. Deprecation warnings are triggered when you use code that's scheduled to be changed or removed. Error and fatal log only errors encountered in the web application, either all of them or just the most severe. I recommend using debug for development. I like to have access to as much information as possible when I'm troubleshooting. In production, I recommend either info or error. You don't need as much information and it reduces the potential for logging sensitive data, like personal information. Log files will grow over time. You can clear them manually from the command line with rails log:clear, or you can use other strategies to truncate or rotate the log files. On production, I usually set up log rotation in Linux but that's outside the scope of this course. In addition to the automatic logging in each category, we can also write custom information to the log files ourselves inside a controller action. This is a useful tool for troubleshooting. We use the logger object and then call a method that corresponds to the log level. We can call debug, info, warn, error or fatal. The log message is sent as an argument. The log message will be logged if the current environment's log level is at or above that level. So if we use debug to log something but the production environment is set to the info log level, then it won't be logged. The log files are inside our project in the log directory. You can see, I have one here for development.log. The configuration for the log level is set in the config directory inside the environments. Let's look at production.rb. If we scroll down, you get to one here that says config.log_level = info. I like that choice. I'm just going to add a comment right above it that gives the other choices that you could have instead, debug, info, warn, error, and fatal. And then I'm going to copy both those lines, save the file, and then let's switch to the development environment. If you scroll down this file, you'll notice that it's not listed. That's because development is using the default setting, which is debug. But I'm going to add a configuration myself, just to make it clear that it is using debug. Now let's go into access controller and do our own custom logging. I'm going to log inside the create action as soon as the create action starts. I'm going to do that with logger.info and then my message, login user. And then I'm going to put in whatever the params were for the username. I like to append something at the front of my log messages to help them stand out from any other log entries. Here, I've added three asterisks. I'm logging this at the info log level. That means that the message will be logged if the environment is set to debug or info but not if it's configured to show only warnings and errors. Let's try it. 

Let's go to the command line and let's first start by clearing the log files with $ rails log:clear . Now my log file is clear. I'll launch the web server. Now let's go into Firefox and let's go to that login page and simulate a login. Now, if we come over here and we scroll down and look at our log file, you'll see that it logged a lot of information about what was going on, some of the database queries that it was making. Here, you can see the custom log message that I added. Notice also that rails filtered out the password that was sent in with the form. That's a nice feature that's there by default. So now we see how the automatic and manual logging works in rails. Logging is a useful tool when you're developing.

Inherit common behaviors with ApplicationController

In this movie, we will learn best practices for inheriting common behaviors in our Rails Application. Ruby classes can inherit behaviors from other Ruby classes. In Rails the controllers are Ruby classes, so they can inherit behaviors from other classes too. This helps us to follow the principle of don't repeat yourself, or DRY for short. Our goal is to define code in only one place and then make it available anywhere it's needed. Class inheritance is a good way to do that. DRY code is consistent, easier to maintain and reduces bugs. Our access controller is a Ruby class that inherits from the application controller class. The application controller class inherits from action controller base, which defines the Rails controller features we've been using, like rendering, redirecting, cookies, sessions and the flash hash. Any code that's in application controller will be available to every controller that inherits from it, and by default, they all do. If you have code that two controllers will use, don't define it twice. Put it in application controller instead. Let's try an example. We have this code in access controller, which finds a username and a user ID. What if more than one action in this controller needs to use it? I'm going to copy that, and I'm going to make a separate method that both of them can call. I'll jump down here to the bottom and I'll make a private method called, get user info from session, and inside I'll just paste those two lines. It's a best practice to designate methods that are not controller actions as private, and any method below this line will be considered private. The controller class in any class that inherits from it will still have access. Now, any of our actions in access controller can call this same method. I'll copy it. Let's go back up here and let's replace this line. And let's say that the new action is going to call the same thing as well. This is DRY and better than repeating this code in every action. But what if more than one controller needed to use it? If we promote it to the super class or parent class application controller, then all our controllers can access it. So, I'll just take these lines right here and I will cut them, save the file. Let's go to application controller and let's just paste those in right here. Now, all our controllers have this same method and they can call it. Let's add another method as well. I'm going to add a new one here. I'm going to call it, logged in, question mark, and it's just going to check to see whether users logged in by checking to see if that session ID has been set. So, if it has been set and it's present, then we'll know that the user's logged in. Now, let's use that in our access controller. It inherits from it, so it has the ability to use it, and let's put it in our new action. If a user goes to the login page, while they're already logged in then let's send them straight to the menu. If logged in, question mark, then let's redirect to menu path. We should also take a moment to add a log out button to our project, or else we'll never see our login page again, once we log in the first time. So, let's go to our menu and let's add one right here. I'm not going to add a link to. I'm going to use button to, which will be very similar, but it works well with a delete action. So, I'll make the text log out and the button will link to log out path, and it will use the method for delete. If you remember in our routes, we have log out defined as being delete. So, we need to do it that way. And then, let's close our ERB tags, and then, we also need to perform the log out. So, here in the destroy, the most important part is that we have the session user ID and that we set it to nil, so that it's no longer marked, but let's also go ahead and add the logger info to the top and the cookies we'll add down here, and let's go ahead and put in a flash notice as well. So, this will just say logged out and the username will be set to nil and the logger info, we're going to say, log out user, and instead of using the prams here let's use the cookies for username before we clear it. Okay, now we're ready to try it out. Let's go and launch our server, and then, let's go to Firefox and let's go to our login page. Now, we are logged in at the moment. So, it used that method right here, logged in, which was defined in application controller, and then it redirected us to the menu page. Now, if I log out, now it takes me to the login page and it does not redirect me this time. Now, we know how to inherit common behaviors from application controller and we can keep our code well organized and DRY.

Use filters to call methods automatically

In this movie, we will learn to use controller filters to call methods automatically. Controller filters execute code before or after a controller action, they can filter requests before allowing actions, they can remove code repetition, or perform basic housekeeping tasks. There are three controller filters, before_action, after_action, and around_action. As their names suggests, before_action executes a method before the action takes place, after_action executes it after the action, and around_action runs code both before and after. The before_action is the filter you will use the most often. Over years of working with Rails, I've only used after and around filters a few times. Our application controller has the get_user_info_from_session method, but it's not being called automatically. Adding before_action, followed by the method name as a symbol, will always call that method before any action. 

I also want to give you an example of how the around_action works. This one is calling a method called buildup_teardown. Inside the method, it performs some code at the start, and then there's the word yield, yield is where control is yielded over to the action. When the action is done, the code below will be run. 

Controller filter methods should be declared private or protected since they're not actions, and any render or redirect that takes place in a before filter will prevent the action from executing. For example, if the user's not logged in, you might redirect them to a login page, and never execute the action. You can specify which actions use a filter with the only or except options, and an array of the methods to include or to exclude. Filters are inherited, but you can skip those inherited filters by using skip_before_action, skip_after_action, and skip_around_action. In our access controller, we're calling get_user_info_from_session two different times here. Instead, we could use a before filter. I'll just copy that and come up here, and do before_action, and then a colon for a symbol, and then the method name. Now I can remove these lines, because it will be happening automatically. Now I can have it take place just for the menu and new actions, or I can make it take place for all of them. Or if I want to, I can take this, and I'll cut it, let's save it and go to our application controller, and I can paste it in here. And now every controller and every action that inherits from ApplicationController will also automatically call get_user_info_from_session. So, if it's set in the cookies in the session, we'll have instance variables username and user_id available throughout our controllers and views. Let's add another method here. This one's going to be confirm_logged_in. And it's going to use the method right above it, and say unless the user is logged in, then we're going to redirect them, and let's also show a flash notice at the same time. The flash notice will say, "Please log in." And we will redirect to the login path. Now let's think about how a before filter like this might work. Where would we put it? We could take it and put it up here, and have before_action, get confirm_logged_in. This would make it so that every single controller and every single action would check to make sure the user was logged in before it let them access that action. We might want most of the pages to be like that, but we definitely don't want all of them to be, because, for one thing, we want to make sure that they can get to the login page and log in, and currently, those pages would redirect too. There are a few different approaches you could take. You could not put this in ApplicationController, but instead put it in each controller one by a time, the ones that are supposed to confirm the login, and we could use something that says except for new and create. Or we could use skip_before_action, and change this from except to only, so it will only skip it for those two. There's no right answer here, it just depends on how your application ought to work. So, let's save it, and let's try it out. rails server. We'll go into Firefox. Now I'm on the login page, let's go to the root of the website first. It took me to the login page, that's because I'm not logged in. kskoglund. Now I'm logged in, I'm on the menu page. Now if we go to the root of the website, no problem, it let me through, it let me come to the task page. Back to menu. If I click Logout, I'm on the login form. But again, if I try now to go to tasks, you see it just takes me to the login page. All those pages are now protected unless the condition inside that confirm_logged_in method is met. We now know how controller filters work, and we've seen a classic example of where filters can be helpful in a Rails project.

RENDERING VIEWS

Avoid double render errors

In this chapter, we'll focus our attention on rendering views. And we'll start by talking about double render errors and how to avoid them. 

A controller action must choose the way any request will be handled. When all the code in the action is done, the action must either render something or redirect to a new URL. Those are the only choices, and it can only choose one. 

Render does not immediately render a template. Instead, it sets the template that will be rendered. And redirect does not immediately redirect. It sets the value and the response to the browser. Neither render nor redirect terminate the action. If we call render or redirect twice in an action, we get an error. 

In this code, if the user's logged in, only render menu will be called. But if a user's not logged in, it will prepare for a redirect and then also call render. Rails will raise a double render error and explain what went wrong. It tells you that you tried to call it multiple times in one action. You can only do it once. And it tells you that they don't terminate the action. So if you want to exit an action, you need to do something like redirect to and return. 

That's one solution. Another solution is just to write your code so that the render and redirect are only encountered one time. Here, I've used an if else clause to ensure that it will only run one or the other, but not both. Or you can do as they suggest and use a return after the render or redirect to stop further execution of any code inside the action. This code would redirect and then immediately exit the action and send the response. Be sure to use the keyword, and, before return. 

Do not use a double ampersand as you might with a true or false logical statement. Every action also has an implicit render. It will render a template with the same name as the action by default. But that implicit render can be overridden without raising any kind of double render error. 

In our example, we were explicitly rendering the menu template in the menu action. 

Another solution would be just to remove that line so that relies on the default behavior to find the template. And then it would work without error. Once you remember that you can only render or redirect once per action, you won't run into double render errors very often.

More options for rendering content

There are many options for rendering content in Ruby on Rails. The most basic, we've encountered already. An action can render its default template, or its code can specify a different template, and we also learned to render partials inside those templates, but let's look at some of the others. 

You can render plain text or HTML text. The response will include only that text. These sort of assume that the response will be short. Otherwise, you would use a template. You can render JSON. You can either write out the JSON as a Ruby hash, or you can provide an object, and Rails will call a toJSON method on it. You can render a hash or an array as XML. Rendering JSON or XML is useful when the controller action is returning data for an API or responding to an AJAX request that will just update a small part of the current page. You can also just return success or failure. This returns plain text for OK but more importantly, it has a status code of 200 for success. 500 would indicate an error, and 404 is used for not found. There are many others. If we left off the plain text, it would render the normal template and just change its status code. So if we really do want to just send back a status, we need to include some kind of a string. You can also render a file. This is an actual file and not an ERB template. Render file will render the file in the browser as is. If you want the user to download the file instead, then send file is a better choice than render and finally, you can render to a string, instead of rendering in the response to the browser. You can assign that string to a variable, parse it, edit it, store in a file, whatever you want to do with it. Let's try these out. I'm going to put some examples inside our menu action. Now, they're commented out at the moment. If we were to just render the menu as it is, we know we would get the default template. Let's see that behavior. I'm going to launch the Rails server, and then let's go into Firefox, and let's make sure that we're logged in because if not, we won't be able to get to our menu page. All right, so I'm just getting the default page now, and we know if we un-commented this line, it would do the same thing. It would just be explicitly rendering the menu, instead of letting the default take place. Let's try rendering the plain text. We'll save that and come back and reload this page, and you see it says, "Just render text." We can un-comment the HTML line and try that one. You see we get back HTML. Let's try the JSUN. Notice that I'm rendering JSON, and I'm just giving it an object. The first task that's in the database. So it goes to the database, looks up the task, and I'm using that object and rendering it back. This might be in response to like an API request. You can see that it rendered the JSON, and Firefox gives me a little bit different view of it but by default, the toJSON method gives us back all of the attributes for that object and the values that go along with them, and then if we were to go to render XML, you see I've just got a simple array, dog, cat and mouse. Let's reload the page. You see it turns that into XML for me, and I can render just the plain status. We won't actually see the status code. We just see the text, but the code is right here. We see it in the console, and you could also see it in the browser inspector as well, and we could change that to different numbers to see how we can change the status code. Let's try a few that work with files. Let's first create a path to a file. So I've got a path to 404 here, and I'm using rails root. That's the root of my project, and I'm joining that with the directories that are inside there and inside the root of my project, inside the public directory, there's a file here called 404.html, and that's the file that I'm going to use just for demonstration purposes. So we can just simply render that file, and it's going to be path to 404, come over here, reload the page, and we get, the page you're looking for doesn't exist. That is the thing that I'm rendering, right? It's not telling me that the page doesn't exist. (chuckles) That's the page I'm actually showing the user. I could instead change that to be a send file. Let's do that here. Do send file, path to 404, and that's going to ask the user if they want to download it, right? So here it downloaded it for me, and let's comment that one out, and let's try another one, which is to make a string out of it. So we'll have a string which is equal to render to string, and we'll put in the file with the path to 404. Now I have the string. What do I want to do with it? I could parse it. I could, you know, search and replace things inside of it, whatever I wanted to do. Let's just, for an example, let's just use our logger in but debug the string, and that'll just take that file and dump it to our log. Let's come over here and reload it. All right, now we solved the default template, but if we come over and look at our log file right here. Let's scroll all the way to the bottom. You'll see there it is. It actually rendered that string to that log file. So I'm going to comment all of these out because what we want is the real actual menu instead, but these will just be placeholders that you can use as reminders of the kinds of things that you could be rendering. Let's just go back one more time and make sure we get our regular menu page. These examples show some of the other options for rendering content besides just rendering the view templates.

Use layouts for shared templates

Layouts are an indispensable tool for giving all the pages and web application a similar look. The pages can share the same structure, the same header and footer, the same navigation, and more. Layouts help to keep our code dry. A layout is a template file that contains the framing HTML for every page, and also an indication for where the custom content for the template should be inserted. We do that by putting the keyword yield inside a set of erb output tags. Rails will render this layout file, and when it reaches yield, it will then yield control to the template that's been set in the controller action. And then when that template is done, it will come back to this layout to render the rest. 

You can configure the layout to use with every action in the controller with layout, followed by the name of the template. By default, the layouts are stored in the app views layouts directory, and the file name ends in .html.erb, because we want Rails to process any erb code that's in that layout. Different controllers can have different layouts. 

You might have one layout for public facing page and another layout for the admin area. They might have a different page structure, load different style sheets, and use different JavaScripts. And you can use accept and only to limit the layout to certain actions. And this example, most actions would use the admin layout, but the access log action will use the report layout. We can skip the layout completely with false, or you can change or skip the layout on a per action basis, using render with the layout option included. 

Let's take a look. So we're going to find our layouts inside app, inside views, inside the layouts directory. And we want to look at application.HTML.erb that Rails gave us by default. You can see that Rails has included some helpful bits for us. We aren't going to worry about those now, but notice the erb tags here with the keyword yield. That's where the template will be dropped in. So right now, anything that's using the application layout will use this shared common HTML. If right above yield, we were to add some code, that would appear on every page that uses this layout. I'm going to paste some HTML right above it for a header. Let me just indent this a little bit. You can pause the movie to copy it down, or it's also included inside the exercise files. Now this header will appear on every single page, and it will show the name, task manager, it will show whether the user is logged in or not, if they're logged in, and give them a button to log out. I can do the same thing down below yield, I'll paste in a footer. So now they can all have a common footer. Everything will have the exact same thing, and I've just got a copyright with the year right there at the bottom. And let's go ahead and take this yield and let's wrap it in a div tag. I'll give it an idea of content. (typing) And let's also give it a style that has a min height of 400 pixels. Let's go over and just check this out. So let's launch the Rails server. Let's go to Firefox, and let's reload our menu page. Look at that. We've got the header at the top, we've got the footer down at the bottom, and we've got the content that gets rendered in between. If we click on Manage Tasks, look at that. It picked up those same changes. So that's throughout our application. Everything that's using that default application layout is going to be getting these same changes. Now on our menu, we already had the user and the logout button. We can now take those away. 

We also had a flash notice that was showing at the top. It would be great to have that on every single one of our pages. So let's take that out. And instead of repeating it on every single page, we can add that to our application. We could just put it right in here, but I also know how to make partials. So let's put it as a partial. We'll have render, partial, and I'm going to call it layout/flash. That's going to be the partial. And then I will come over here to the layouts directory, and I will make a new file, which I will call _flash.html.erb. And then let's paste that code in there. And that'll just show our flash notice at the top of every page. We go back now and just try that out. Let's log out and then log back in. (typing) Look at that. It's at the top of all our pages. And when we log out, right, we see that it says logged out at the top of the form page, which it didn't used to do. (typing) And now we have it back here again. Now we didn't explicitly put that at the top of the access controller, but we could. So let's just add that. This will use the application layout, but it's also the default if we don't specify something different. You can see how layouts are a useful tool for managing the look of your webpages.

Capture content for later use

In this movie, we'll learn to use another useful feature of templates: the ability to capture content for later use. To do that, I'm going to introduce you to two Ruby on Rails helper methods, content_for, and content_for? with a question mark. The first method captures content and assigns it to a name. That content can either be a string or a block of code. And the second method will check to see if any content has been captured for a name. On a page template, we can use content_for, and pass an assemble to use as the identifier name. Then in a code block, which is everything from do to end, is the content that's going to be captured. This content will not be output immediately. It'll be held in reserve until other code calls for it. You can capture different content using different identifiers. If you use the same identifier more than once, the content will be concatenated, not replaced. We can use the captured content by yielding with the content identifier. For example, this is a layout that has a yield in the HTML head, that asks for any stored content for script. The content captured on the previous template would be dropped in here. It may seem odd that this layout won't actually yield to the viewed template until a few lines further down, but Rails does some pre-processing that makes this possible. Let me give you another example. Here's an HTML layout that sets the HTML title to any text captured for title, or default text if none is found. And then, it will check for content captured for sidebar, and display it with HTML tags around it, if it exists. Let's try it in our project. Let's go back to our application layout, and let's add a yield for JavaScript content. We'll do it right here at the very end. I'll put ERB tags that output anything that has been stored for script. Now, any template that uses this layout can capture JavaScript, and it would be output in the HTML head. Let's try that by going to our About page that's over here in Main and About, and at the bottom of this page, let's just add content_for(:script) do and end. Now everything that's inside that code block, from do to end, is going to be captured. So let's put in some script tags, and inside those, we'll just put alert that says, "Welcome!" Now, before we try it out, let's go back to our layout and let's add in another one here in the title. So we have Task Manager. I'm going to put some ERB output tags immediately after it, with no space. And then, it will output a separator that is " - " + yield whatever has been captured for a title, if content_for?(:title) exists. Now, the reason I have this "if" here, and I'm not just letting this return nothing, is because I want to suppress this divider if there is no title to be shown. Now we can save that and jump back to our About page. And at the top of our About page, let's just capture a page title. So we'll have content_for(:title), and this time, instead of using a code block, let's just use a string. So we'll just call this 'About.' And I'll copy this and let's go to our Menu page. And at the top of the Menu page, we'll put one for 'Menu.' And we could do this for every single page in our site. It'll set the title of the page that's going to be in the HTML layout, but it will do it from the template. If we try this out, let's go to our command line and launch our server. Now we come here, let's go to our About page. Here's our welcome message. And you see, it says, "Task Manager - About." Click back to Menu. It says, "Task Manager - Menu." And if you were review source, you would see that it actually had added those in the HTML at the places you would expect. It's useful to be able to capture content in the template, which is used in a different area of the page.

INCORPORATING ASSETS

Add stylesheets to view templates

In this chapter, we will learn to work with assets in Ruby on Rails, beginning with style sheets. We can work with style sheets two ways. The simplest is to put a style sheet in the public directory of the project and then add a link in the layout that refers to it. Or you can use a feature called asset pipeline. 

Using the asset pipeline has several benefits. It will concatenate several style sheets together and pre-compile the style sheets. This compresses and minifies the files, removes white space and comments and allows writing styles in other languages like SAS. And the asset pipeline does asset fingerprinting which helps browsers keep cached assets up to date. If the file contents change, the fingerprint changes and the browser looks for an updated file. 

If you use asset pipeline, style sheets are kept in app/assets/style sheets, and the file names should end in .css. 

To use the asset pipeline, there are four steps to follow: 

 - First, the asset precompile list needs to include a manifest file. 

 - That manifest file will list all of the style sheets that will be processed and concatenated together. 

 - Then we can add a style sheet link tag to our layout. 

 - And finally, if you're deploying the site, you'll need to tell Rails to process and concatenate all the files into one. 

Let's look at these steps in our Rails app. 

The first step is to make sure the asset precompile list includes the manifest file we want. That's located inside the config directory, inside initializers and assets.rb. You can see right here, precompile additional assets. It tells us that by default, application.css will already be included. But if we had a different manifest file that we wanted to use, then we would uncomment this line and make sure that we added it to this list. For example, they've included a manifest file called admin here for you already. Now, we're not going to do that. We're going to use the default one so we can leave this alone. But that's step one, to make sure that we have a manifest file listed in the assets precompile list. 

Step two is to go to app, assets, style sheets to find that manifest file and make sure that it lists the style sheets that we want. This looks like it's one big code comment in CSS but these lines here that have equal signs are actually instructions to asset pipeline. 

The first one tells asset pipeline to include all CSS files that are in the current directory. 

Right now, there are no others, but we can add one. Let's add a new file here and I'm going to call it structure.css. Now, that file will be included because of require tree. Require tree will include every file in alphabetical order. Then require self will also include any CSS that's included in this manifest itself, anything that's below the code comments. Here's another example of a manifest file. Instead of using require tree or require self, it is loading individual files by name in a specific order. Some files are in a sub-directory called public. This makes it easy to maintain specialized style sheets that will be assembled into one. So we've taken care of steps one and two. 

Step three is to go to our layout and make sure that we're loading in the style sheet, using stylesheet link tag and we're loading in the application. That is the name of the manifest file that's going to be compiled, the end result of all those CSS files being put together will be called application. (Don't worry about this code related to turbo links. That's a feature of Rails that allows pages to load faster.) 

Let's move some of our inline styles that are here into our style sheet. I'm going to paste those in. It's the same thing that we had in there. I'll save the file and we can go back and we can now remove all these inline styles. And there's one here and one down here in the footer. 

So now instead of having inline styles, they're all inside structure.css which should be compiled and loaded for us to use. Let's go over here and try it. We'll launch the server and then let's go into Firefox and let's just reload our page. And you can see, we still get the styles, even when we switch to different pages. It's loading in those styles that are all coming from the style sheet. So we have a manifest file that lists the style sheets and a layout that loads the compiled style sheet. 

In development, we don't need an extra step to compile them. Rails handles it for us. But for production where speed really matters, we need to add a step. To precompile, first make sure that the environment is set to production. Then use the command, 

 *** bundle exec rails assets:precompile ***

This will pre-process the files and cancatenate them into a file according to each manifest. If you're using a tool to help you deploy like Capistrano or a hosted service like Heroku or Engine Yard, they include scripts to do this for you automatically. Using style sheets with asset pipeline can require a little extra configuration but it has big benefits.

Use static image assets

In this movie, we'll learn how to work with static images in our Rails projects. What I refer to as static images are images that are stored with our project code. They don't change unless we change our project and deploy it again. Static images might include logos, buttons, icons, or other elements of the site's user interface. Dynamic images, on the other hand, would be images that are uploaded after a project is deployed. They're typically stored on the server in a file system or in a database and they can be updated. Dynamic images might include product images, or user submitted photos. Dynamic images are beyond the scope of this course. If you want to learn more about them, you can read up on a Rails feature called, Active Storage. We will focus on static images. There are two ways we can work with static images. The simplest is just to put images in the public directory, inside an images directory, and then use a simple HTML tag to reference it, or we can use the asset pipeline, like we did with style sheets. The asset pipeline makes it easy for helper methods to work with our images. It performs asset fingerprinting by adding a hash to the image file name. Then if the image content changes, the file name changes and the browser will look for a revised image. We just need to put our images in app/assets/images. Then when we want to refer to those images, we won't use a simple HTML tag. We'll want to use a Rails helper because, remember, asset fingerprinting will change the name of the file, but rails will handle that for us if we use image_tag and then provide the name of the original image. You can add options like size, alt, width and height to customize how it appears. Let's try it out. In the exercise files, I've added an image asset to app assets, images. It's called taskmanager_logo.png. Let's add it to the top of every webpage, where right now we have the word task manager, let's replace that with an image of the logo. So, I'll delete the text and I'll use ERB tags and inside them I'll use that image tag helper, and the first argument to the image tag helper is the name of the original image, which is taskmanagerlogo.png. Then I can provide any options I want. I'm going to set the height to 25 and add an alt tag for task manager logo. I'll save the file. Now, let's take a look. We'll launch the server and then we'll go to Firefox. You can see what it looks like before when it just has simple text. Now, we'll reload the page, and now we get an image instead. If we go up here to our tools and choose web developer tools to look at the page source, in the header, you'll see the image tag that it created, and you see that it put it in the assets directory, and you can also see the asset fingerprinting that it did at the end. So, the file's not called task manager logo anymore. It's task manager logo with a long string of letters and numbers appended to it, but Rails handles all that for you. All you have to do is use the image helper tag. We can also put images inside a link. For example, we could make a link to the homepage. So, when you click on the logo, it takes you back to the menu. All I have to do is use link to in front of it, and the first argument instead of text, will be the image, and then after that, I'll put the path. I'll put it for menu path, save it. And we come up here and we can reload the page. And now, when I click on it you can see it takes me to the menu. Even better I think, is a nice little trick. I'm going to undo the code that I wrote, and I can make this link to up here, and I will use a block format for it instead. Now, this we don't normally do. Normally, you just put the link text in there, but it does accept a block, and so everything from due to end will be what is linked. So, I don't need a first argument anymore for my link. I just need the second argument, which is menu path. Let's save it. Let's come back over here and reload it, and let's go to manage tasks. We click on task manager, takes us back to the menu. I think this is a little cleaner when we're wrapping images inside links. We've managed to use asset pipeline to put a static image on our page, and we also learned how to wrap a link around it.

Use images as CSS backgrounds

Sometimes we want to use an image as a CSS background and not just in an HTML image tag. Rails has helper methods to assist you if you're using the asset pipeline. This is how to add an inline style with a background image. You can use this in Rails. However, it won't work well if you're using the asset pipeline. The file won't be called logo.png. The asset pipeline will copy the images to a new location and append a fingerprint to each file name. You won't know the name ahead of time, and it will change if the image content changes. Instead, you can use the helper method image path and Rails will provide the correct path and file name. It's similar to image tag, but it only returns the path, not the entire HTML tag. If you want to set a background to an asset pipeline image in your style sheet, then you have two choices. First, you can add the .erb file extension to your CSS files. When Rails compile them, it will evaluate the erb that's inside. That will allow you to use the same image path helper as we did in the HTML template. Or you can enable the Sass gem, and use the image URL helper that's provided with it. In Rails versions 5 and 6, Sass was enabled by default. So this was a common way to do it, but in Rails 7, you must enable Sass to use it. Let's try these in our project. Let's add a gradient as a background image to the header and the footer. I've included a gradient image in the exercise files in app, assets, images. It's called gradient.png. First, let's add it as an inline style. We can do that right here in our layout. So we have our header. We'll just add style equals background image, URL, and inside that we'll have single quotes. And then we'll put our erb tags where we're going to output the value that image path gives us. So image path for gradient.png. All right, let's save it. Let's try it out. We'll launch our server. We'll go over here to Firefox. Let's just reload our page, and you see it switched to a gradient image. It starts out darker, and it becomes lighter when it gets over to this side. Okay. Now let's add it to our style sheet. I won't demonstrate how to turn on Sass, but I will show you that you can enable it by going into your gem file and then finding the Sass gem right here. It's called sassc-rails. And if you just uncomment this line, and then go to your command line and run bundle install, then it will install the gem. That's all there is to it. Instead of using Sass though, I'm going to change our style sheet up here so that its name ends in .erb. That will cause it to be pre-processed by erb to give us a CSS file. Now I'll close up the gem file. Let's go back to here. Let's take this inline style and remove it. And, instead, let's come over here to structure and right below the background, we'll put in the background image with the same path that we had before. And I'll just take that same line and come down here and do it in the footer as well. So let's save it. We'll go back. Let's reload the page, and it worked. Both our header and our footer now have our gradient image. That's how you use images as CSS backgrounds.