https://github.com/LinkedInLearning/ruby-on-rails-controllers-and-views-2498312

You can also run rails lil:import anytime you want to get the database data in the same state as mine.

USEFUL CONTROLLER FEATURES

Store data in cookies

In this chapter, we'll explore several useful controller features, beginning with learning how cookies work in Ruby on rails. HTML is stateless. Each request from the browser to the web server is distinct. And the state of the user's interaction with the web application and information related to previous requests is not automatically preserved. 

Cookies are an efficient way for web application to keep track of data across requests. When responding to a request, the web server can send data to the browser for it to store in a cookie on the user's local computer. Then the browser will send that cookie data back with each and every future request. 

You should set cookies and retrieve their data inside your controllers, not in the views or in the models. Setting cookies is like working with a standard Ruby hash. You can set a cookie by setting a key and value in cookies. 

Here I'm setting a cookie with the key, username, and a value of J Smith. This is the simplest and most common usage, but you can include other options like an expiration time. Behind the scenes, Rails will prepare to send this data in the response to the current request. The browser will then send that data back with all future requests. 

And you can read cookies also like you're working with a standard Ruby hash. Here I'm reading the value stored for the key, username, and I'm assigning it to an instance variable. 

Cookies have some limitations to keep in mind. First they have a maximum data size of four kilobytes, which is about 4,000 characters. They're designed to store small amounts of data. And that's good because the cookie data is send with every request, even if the web server won't make use of it. Never store instances of models in your cookies. They're usually too large and their data may become outdated. Cookies also reside on the user's computer. You should not assume that they're secret. They can be read, deleted, or altered. So don't store sensitive data in plain text. And always exercise caution when using data from cookies. 

Let's try an example. The exercise files include a Ruby on Rails application, which is based on the project we created in Ruby on Rails Essential Training, the task manager. I've added an access controller to allow us to simulate a login. It has several actions. And those are listed in the routes file too. You see, we have a resource for access. We also have some shortcuts that allow us to use login in order to get to access new and so on. 

Let's fire it up. From the root of our project, I'll type rails server. And then we'll go to Firefox and load localhost:3000. You can see, we get the list of tasks, but I'm interested in that login page, which is going to be /login or /accessnew. This is a simulated login form. When it's submitted, I do not intend to actually search for a username and password in the database. We're going to fake that part of the process, but it will submit to the create action. You can see, here's the new action that displays the form and the create action that will process the form. 

In the create action, let's just set a cookie to whatever username we were given as if it had existed in the database. So right here, we'll add cookies. And the key we'll use is username. We'll set it equal to the value of params:username. Be sure to make cookies plural. It's a container for many cookies. When the response is then send to the browser, it will include this cookie. The browser will save the cookie to send it with every future request. The create action ends with a redirect so that the next request will happen right away. 

It'll be routed to the menu action. In the menu action, we can read the value of the cookie. Let's do that and set it to the instance variable for username = cookies:username. From there, it will render the menu template. So let's use that instance value on the template. I'll just put some P tags here, and inside user, and then some ERB tags that will have username instance variable in it. Let's try it out. I'll come back over here to the form. 

And before I submit something, I'm also going to just open up the tools for Firefox, and go to Web Developer Tools, and choose the Network tab. 

That'll let me see the network activity. I'll put in a username. I don't need to put in a password since I'm not actually logging in. When I click login, you can see that it does display the value that we submitted that came back from the cookie. 

We can also look at the network information. And we'll see there's two requests. The first was the post request to access. And then we're redirected with the 302 redirect to the get request for menu. On the post request, if we click on cookies, we can see the response cookies, we scroll down here. Let me actually just pull this one up. Here's the username cookie with a value of kskoglund. That was send in the response back to the browser. Then the browser turned right around and submitted a new request. 

And let's look not at the response cookies this time, but the request cookies that it send. And you can see it included a cookie with the username kskoglund. We've successfully learned how to use cookies in our Ruby on Rails projects.

Store data in sessions

In this movie, we will learn how to store data in sessions, which are similar to cookies. 

With sessions, the web server sends a session identifier to the browser, which then saves it in a cookie. The browser sends that session identifier with every future request, just like with cookies, and Rails will automatically use the identifier to locate a storage area on the server, usually a file or a database, and make the data available to the web application. 

You can set and retrieve values in the session inside your controllers using the same hash notation that we used with cookies. Here, I'm defining the key language in the session and setting it to the string en. And then in future request, I can retrieve values from the session storage using the key. Here I'm using language. Behind the scenes, Rails will handle the data storage for you. 

Sessions do have some limitations. Retrieving the session file can add time to every request, especially if it uses the file system. The session files can accumulate and take up space. 1 million users means 1 million session files. It may be necessary to prune old session files occasionally. 

Session data is often stored on the server, but the session identifier is still stored on the user's computer. So that means that that session cookie can be deleted or stolen. Ruby on Rails offers several session storage options. In the file system, in a database table, in a cache like Redis, or in a cookie. 

In the past, Rails use file storage and database storage as defaults, and these remain popular options in other web development frameworks. However, the current default in Ruby on Rails is cookie storage. Cookie storage works a little bit differently than the other three. Rails will store session data in a cookie sent to the user's browser. This special cookie or super cookie will be encrypted to prevent reading its data, and cryptographically signed to prevent tampering. 

Unlike the other storage choices on the server side, there's no extra load time and no session files to accumulate or bloat our server. Of course, like all cookies, the data must be less than 4 K in size. But in most circumstances, that's enough. Cookie storage is a great choice, and I encourage you to use it. Rails manages the session cookie storage for us, including encrypting and signing the cookie data. 

When you create a new Rails app, Rails creates a master key file in the config directory and uses it for encrypting the credentials file. The credentials file includes the data used to encrypt and sign cookies. The encrypted credentials file can be shared as long as the master key is kept secret. Rail sets all of this up when a project is created. So you won't usually need to change anything. But you can edit the credentials with rails credentials:edit. 

Because they're encrypted, you'll also need to tell your text editor to wait so that you can edit a plain text version, and then let Rails encrypt your changes when the file is closed. Let's try working with them. In my Rails app, inside the config directory, you can see that I have credentials.yml.enc, which is some encrypted data in it. And then I have master key, which is just a simple password used to encrypt and decrypt those credentials. If you created your project from scratch, you will also have a master key file. But if you're using the course exercise files, you won't have it because it's automatically added to the gitignore file and isn't included in the repository. But that's okay. You don't need it for this example. 

I won't walk you through the editing process. Instead, let's try using the session. Let's go to access_controller, and let's add a user id to the session when a user logs in. So right here underneath the cookies, we'll put session, and the key for this will be user_id, and then I'm going to make up an ID 1483, and I'll just add a space here. The user id is a little more sensitive than the username. We're mostly storing that username for efficiency. We'll use the user id as an indication of whether the user is logged in or not. It's better not to put that in a cookie where it can be viewed or edited. So we're going to keep it in the session where it'll be safer. Then in our menu action, we can read that value from the session and set it to an instance variable. I'll have the instance variable user id, and I'll use session, and we'll have the key of user id. Let's save the file, and then let's go to our menu page, and let's use it here as well. I'll just put parentheses, and then some ERB tags to display the user id, just so we can see that we're reaching that value back. 

Let's try it out. Let's go here and launch our server. We'll open up Firefox. And we don't want the menu anymore. We want the login page. And I'm going to put in username kskoglund2, just so we can see a little bit of a difference. Click Log in. See the username there. And we see the made up ID, 1483. Now we know how to use both cookies and sessions to store data. I recommend that you use cookies for data that's not sensitive and should persist for weeks or even for months. Use sessions for everything else.

Messaging with the flash hash

In this movie, we will learn how to use a useful controller feature called the flash hash. The flash hash stores short messages in the session data. It's useful when a controller action will redirect to another action and we want to preserve a message so that the second action can retrieve it. It's for storing text strings, not Ruby objects or other data. Ruby on Rails keeps a message in the flash hash for exactly one additional request and then it automatically clears it. Of course you could store and retrieve text from the session yourself but the flash hash automates the process and makes it easier. This code demonstrates the primary use case for the flash hash. A controller action creates a new record and then redirects. The redirect will cause the browser to make a second request to a new controller action. And that second action doesn't automatically have information about what happened in the first action. But by putting a message in the flash hash, the message can be retrieved and used by the second action. In this case, the second action would probably show that success message in addition to the normal template that it renders. Flash hash messages are set by assigning a string to a key or a label. The most common label on flash messages is notice. You can choose any label you want though and you may decide to display them differently depending on the label. For example, the text flash notice could be colored blue. A flash error could be red. A flash alert could be orange and so on. If in doubt, stick with notice.

Log information to a file

In this movie, we will learn how to log custom information from controller actions. When a project is deployed, there are typically two sets of logs, server logs, and application logs. The web server will log basic data about each request as well as any errors that it encounters. The web server can see the request and the response but it does not know what happens inside the web application. The web application will log its activity in the application logs. It can provide useful information, especially for troubleshooting. The application logs are stored in the log directory. There's one log for each environment. When our project is running in development mode, we'll look for log output in the development log. You can configure the type of information that gets logged automatically and you can have different configurations for each environment. For example, you might set development to log a lot of information and production to log less. There are five log levels that you can choose from, debug, info, warn, error, and fatal. They log different amounts of information. In the first column, you can see that debug logs the most. It logs database queries, request and render details, deprecation, standard errors and fatal errors. Info is similar but without the database queries. Warn logs only errors and deprecation warnings. Deprecation warnings are triggered when you use code that's scheduled to be changed or removed. Error and fatal log only errors encountered in the web application, either all of them or just the most severe. I recommend using debug for development. I like to have access to as much information as possible when I'm troubleshooting. In production, I recommend either info or error. You don't need as much information and it reduces the potential for logging sensitive data, like personal information. Log files will grow over time. You can clear them manually from the command line with rails log:clear, or you can use other strategies to truncate or rotate the log files. On production, I usually set up log rotation in Linux but that's outside the scope of this course. In addition to the automatic logging in each category, we can also write custom information to the log files ourselves inside a controller action. This is a useful tool for troubleshooting. We use the logger object and then call a method that corresponds to the log level. We can call debug, info, warn, error or fatal. The log message is sent as an argument. The log message will be logged if the current environment's log level is at or above that level. So if we use debug to log something but the production environment is set to the info log level, then it won't be logged. The log files are inside our project in the log directory. You can see, I have one here for development.log. The configuration for the log level is set in the config directory inside the environments. Let's look at production.rb. If we scroll down, you get to one here that says config.log_level = info. I like that choice. I'm just going to add a comment right above it that gives the other choices that you could have instead, debug, info, warn, error, and fatal. And then I'm going to copy both those lines, save the file, and then let's switch to the development environment. If you scroll down this file, you'll notice that it's not listed. That's because development is using the default setting, which is debug. But I'm going to add a configuration myself, just to make it clear that it is using debug. Now let's go into access controller and do our own custom logging. I'm going to log inside the create action as soon as the create action starts. I'm going to do that with logger.info and then my message, login user. And then I'm going to put in whatever the params were for the username. I like to append something at the front of my log messages to help them stand out from any other log entries. Here, I've added three asterisks. I'm logging this at the info log level. That means that the message will be logged if the environment is set to debug or info but not if it's configured to show only warnings and errors. Let's try it. 

Let's go to the command line and let's first start by clearing the log files with $ rails log:clear . Now my log file is clear. I'll launch the web server. Now let's go into Firefox and let's go to that login page and simulate a login. Now, if we come over here and we scroll down and look at our log file, you'll see that it logged a lot of information about what was going on, some of the database queries that it was making. Here, you can see the custom log message that I added. Notice also that rails filtered out the password that was sent in with the form. That's a nice feature that's there by default. So now we see how the automatic and manual logging works in rails. Logging is a useful tool when you're developing.

Inherit common behaviors with ApplicationController

In this movie, we will learn best practices for inheriting common behaviors in our Rails Application. Ruby classes can inherit behaviors from other Ruby classes. In Rails the controllers are Ruby classes, so they can inherit behaviors from other classes too. This helps us to follow the principle of don't repeat yourself, or DRY for short. Our goal is to define code in only one place and then make it available anywhere it's needed. Class inheritance is a good way to do that. DRY code is consistent, easier to maintain and reduces bugs. Our access controller is a Ruby class that inherits from the application controller class. The application controller class inherits from action controller base, which defines the Rails controller features we've been using, like rendering, redirecting, cookies, sessions and the flash hash. Any code that's in application controller will be available to every controller that inherits from it, and by default, they all do. If you have code that two controllers will use, don't define it twice. Put it in application controller instead. Let's try an example. We have this code in access controller, which finds a username and a user ID. What if more than one action in this controller needs to use it? I'm going to copy that, and I'm going to make a separate method that both of them can call. I'll jump down here to the bottom and I'll make a private method called, get user info from session, and inside I'll just paste those two lines. It's a best practice to designate methods that are not controller actions as private, and any method below this line will be considered private. The controller class in any class that inherits from it will still have access. Now, any of our actions in access controller can call this same method. I'll copy it. Let's go back up here and let's replace this line. And let's say that the new action is going to call the same thing as well. This is DRY and better than repeating this code in every action. But what if more than one controller needed to use it? If we promote it to the super class or parent class application controller, then all our controllers can access it. So, I'll just take these lines right here and I will cut them, save the file. Let's go to application controller and let's just paste those in right here. Now, all our controllers have this same method and they can call it. Let's add another method as well. I'm going to add a new one here. I'm going to call it, logged in, question mark, and it's just going to check to see whether users logged in by checking to see if that session ID has been set. So, if it has been set and it's present, then we'll know that the user's logged in. Now, let's use that in our access controller. It inherits from it, so it has the ability to use it, and let's put it in our new action. If a user goes to the login page, while they're already logged in then let's send them straight to the menu. If logged in, question mark, then let's redirect to menu path. We should also take a moment to add a log out button to our project, or else we'll never see our login page again, once we log in the first time. So, let's go to our menu and let's add one right here. I'm not going to add a link to. I'm going to use button to, which will be very similar, but it works well with a delete action. So, I'll make the text log out and the button will link to log out path, and it will use the method for delete. If you remember in our routes, we have log out defined as being delete. So, we need to do it that way. And then, let's close our ERB tags, and then, we also need to perform the log out. So, here in the destroy, the most important part is that we have the session user ID and that we set it to nil, so that it's no longer marked, but let's also go ahead and add the logger info to the top and the cookies we'll add down here, and let's go ahead and put in a flash notice as well. So, this will just say logged out and the username will be set to nil and the logger info, we're going to say, log out user, and instead of using the prams here let's use the cookies for username before we clear it. Okay, now we're ready to try it out. Let's go and launch our server, and then, let's go to Firefox and let's go to our login page. Now, we are logged in at the moment. So, it used that method right here, logged in, which was defined in application controller, and then it redirected us to the menu page. Now, if I log out, now it takes me to the login page and it does not redirect me this time. Now, we know how to inherit common behaviors from application controller and we can keep our code well organized and DRY.

Use filters to call methods automatically

In this movie, we will learn to use controller filters to call methods automatically. Controller filters execute code before or after a controller action, they can filter requests before allowing actions, they can remove code repetition, or perform basic housekeeping tasks. There are three controller filters, before_action, after_action, and around_action. As their names suggests, before_action executes a method before the action takes place, after_action executes it after the action, and around_action runs code both before and after. The before_action is the filter you will use the most often. Over years of working with Rails, I've only used after and around filters a few times. Our application controller has the get_user_info_from_session method, but it's not being called automatically. Adding before_action, followed by the method name as a symbol, will always call that method before any action. 

I also want to give you an example of how the around_action works. This one is calling a method called buildup_teardown. Inside the method, it performs some code at the start, and then there's the word yield, yield is where control is yielded over to the action. When the action is done, the code below will be run. 

Controller filter methods should be declared private or protected since they're not actions, and any render or redirect that takes place in a before filter will prevent the action from executing. For example, if the user's not logged in, you might redirect them to a login page, and never execute the action. You can specify which actions use a filter with the only or except options, and an array of the methods to include or to exclude. Filters are inherited, but you can skip those inherited filters by using skip_before_action, skip_after_action, and skip_around_action. In our access controller, we're calling get_user_info_from_session two different times here. Instead, we could use a before filter. I'll just copy that and come up here, and do before_action, and then a colon for a symbol, and then the method name. Now I can remove these lines, because it will be happening automatically. Now I can have it take place just for the menu and new actions, or I can make it take place for all of them. Or if I want to, I can take this, and I'll cut it, let's save it and go to our application controller, and I can paste it in here. And now every controller and every action that inherits from ApplicationController will also automatically call get_user_info_from_session. So, if it's set in the cookies in the session, we'll have instance variables username and user_id available throughout our controllers and views. Let's add another method here. This one's going to be confirm_logged_in. And it's going to use the method right above it, and say unless the user is logged in, then we're going to redirect them, and let's also show a flash notice at the same time. The flash notice will say, "Please log in." And we will redirect to the login path. Now let's think about how a before filter like this might work. Where would we put it? We could take it and put it up here, and have before_action, get confirm_logged_in. This would make it so that every single controller and every single action would check to make sure the user was logged in before it let them access that action. We might want most of the pages to be like that, but we definitely don't want all of them to be, because, for one thing, we want to make sure that they can get to the login page and log in, and currently, those pages would redirect too. There are a few different approaches you could take. You could not put this in ApplicationController, but instead put it in each controller one by a time, the ones that are supposed to confirm the login, and we could use something that says except for new and create. Or we could use skip_before_action, and change this from except to only, so it will only skip it for those two. There's no right answer here, it just depends on how your application ought to work. So, let's save it, and let's try it out. rails server. We'll go into Firefox. Now I'm on the login page, let's go to the root of the website first. It took me to the login page, that's because I'm not logged in. kskoglund. Now I'm logged in, I'm on the menu page. Now if we go to the root of the website, no problem, it let me through, it let me come to the task page. Back to menu. If I click Logout, I'm on the login form. But again, if I try now to go to tasks, you see it just takes me to the login page. All those pages are now protected unless the condition inside that confirm_logged_in method is met. We now know how controller filters work, and we've seen a classic example of where filters can be helpful in a Rails project.