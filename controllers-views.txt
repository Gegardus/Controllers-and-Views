https://github.com/LinkedInLearning/ruby-on-rails-controllers-and-views-2498312

You can also run rails lil:import anytime you want to get the database data in the same state as mine.

USEFUL CONTROLLER FEATURES

Store data in cookies

In this chapter, we'll explore several useful controller features, beginning with learning how cookies work in Ruby on rails. HTML is stateless. Each request from the browser to the web server is distinct. And the state of the user's interaction with the web application and information related to previous requests is not automatically preserved. 

Cookies are an efficient way for web application to keep track of data across requests. When responding to a request, the web server can send data to the browser for it to store in a cookie on the user's local computer. Then the browser will send that cookie data back with each and every future request. 

You should set cookies and retrieve their data inside your controllers, not in the views or in the models. Setting cookies is like working with a standard Ruby hash. You can set a cookie by setting a key and value in cookies. 

Here I'm setting a cookie with the key, username, and a value of J Smith. This is the simplest and most common usage, but you can include other options like an expiration time. Behind the scenes, Rails will prepare to send this data in the response to the current request. The browser will then send that data back with all future requests. 

And you can read cookies also like you're working with a standard Ruby hash. Here I'm reading the value stored for the key, username, and I'm assigning it to an instance variable. 

Cookies have some limitations to keep in mind. First they have a maximum data size of four kilobytes, which is about 4,000 characters. They're designed to store small amounts of data. And that's good because the cookie data is send with every request, even if the web server won't make use of it. Never store instances of models in your cookies. They're usually too large and their data may become outdated. Cookies also reside on the user's computer. You should not assume that they're secret. They can be read, deleted, or altered. So don't store sensitive data in plain text. And always exercise caution when using data from cookies. 

Let's try an example. The exercise files include a Ruby on Rails application, which is based on the project we created in Ruby on Rails Essential Training, the task manager. I've added an access controller to allow us to simulate a login. It has several actions. And those are listed in the routes file too. You see, we have a resource for access. We also have some shortcuts that allow us to use login in order to get to access new and so on. 

Let's fire it up. From the root of our project, I'll type rails server. And then we'll go to Firefox and load localhost:3000. You can see, we get the list of tasks, but I'm interested in that login page, which is going to be /login or /accessnew. This is a simulated login form. When it's submitted, I do not intend to actually search for a username and password in the database. We're going to fake that part of the process, but it will submit to the create action. You can see, here's the new action that displays the form and the create action that will process the form. 

In the create action, let's just set a cookie to whatever username we were given as if it had existed in the database. So right here, we'll add cookies. And the key we'll use is username. We'll set it equal to the value of params:username. Be sure to make cookies plural. It's a container for many cookies. When the response is then send to the browser, it will include this cookie. The browser will save the cookie to send it with every future request. The create action ends with a redirect so that the next request will happen right away. 

It'll be routed to the menu action. In the menu action, we can read the value of the cookie. Let's do that and set it to the instance variable for username = cookies:username. From there, it will render the menu template. So let's use that instance value on the template. I'll just put some P tags here, and inside user, and then some ERB tags that will have username instance variable in it. Let's try it out. I'll come back over here to the form. 

And before I submit something, I'm also going to just open up the tools for Firefox, and go to Web Developer Tools, and choose the Network tab. 

That'll let me see the network activity. I'll put in a username. I don't need to put in a password since I'm not actually logging in. When I click login, you can see that it does display the value that we submitted that came back from the cookie. 

We can also look at the network information. And we'll see there's two requests. The first was the post request to access. And then we're redirected with the 302 redirect to the get request for menu. On the post request, if we click on cookies, we can see the response cookies, we scroll down here. Let me actually just pull this one up. Here's the username cookie with a value of kskoglund. That was send in the response back to the browser. Then the browser turned right around and submitted a new request. 

And let's look not at the response cookies this time, but the request cookies that it send. And you can see it included a cookie with the username kskoglund. We've successfully learned how to use cookies in our Ruby on Rails projects.

Store data in sessions

In this movie, we will learn how to store data in sessions, which are similar to cookies. 

With sessions, the web server sends a session identifier to the browser, which then saves it in a cookie. The browser sends that session identifier with every future request, just like with cookies, and Rails will automatically use the identifier to locate a storage area on the server, usually a file or a database, and make the data available to the web application. 

You can set and retrieve values in the session inside your controllers using the same hash notation that we used with cookies. Here, I'm defining the key language in the session and setting it to the string en. And then in future request, I can retrieve values from the session storage using the key. Here I'm using language. Behind the scenes, Rails will handle the data storage for you. 

Sessions do have some limitations. Retrieving the session file can add time to every request, especially if it uses the file system. The session files can accumulate and take up space. 1 million users means 1 million session files. It may be necessary to prune old session files occasionally. 

Session data is often stored on the server, but the session identifier is still stored on the user's computer. So that means that that session cookie can be deleted or stolen. Ruby on Rails offers several session storage options. In the file system, in a database table, in a cache like Redis, or in a cookie. 

In the past, Rails use file storage and database storage as defaults, and these remain popular options in other web development frameworks. However, the current default in Ruby on Rails is cookie storage. Cookie storage works a little bit differently than the other three. Rails will store session data in a cookie sent to the user's browser. This special cookie or super cookie will be encrypted to prevent reading its data, and cryptographically signed to prevent tampering. 

Unlike the other storage choices on the server side, there's no extra load time and no session files to accumulate or bloat our server. Of course, like all cookies, the data must be less than 4 K in size. But in most circumstances, that's enough. Cookie storage is a great choice, and I encourage you to use it. Rails manages the session cookie storage for us, including encrypting and signing the cookie data. 

When you create a new Rails app, Rails creates a master key file in the config directory and uses it for encrypting the credentials file. The credentials file includes the data used to encrypt and sign cookies. The encrypted credentials file can be shared as long as the master key is kept secret. Rail sets all of this up when a project is created. So you won't usually need to change anything. But you can edit the credentials with rails credentials:edit. 

Because they're encrypted, you'll also need to tell your text editor to wait so that you can edit a plain text version, and then let Rails encrypt your changes when the file is closed. Let's try working with them. In my Rails app, inside the config directory, you can see that I have credentials.yml.enc, which is some encrypted data in it. And then I have master key, which is just a simple password used to encrypt and decrypt those credentials. If you created your project from scratch, you will also have a master key file. But if you're using the course exercise files, you won't have it because it's automatically added to the gitignore file and isn't included in the repository. But that's okay. You don't need it for this example. 

I won't walk you through the editing process. Instead, let's try using the session. Let's go to access_controller, and let's add a user id to the session when a user logs in. So right here underneath the cookies, we'll put session, and the key for this will be user_id, and then I'm going to make up an ID 1483, and I'll just add a space here. The user id is a little more sensitive than the username. We're mostly storing that username for efficiency. We'll use the user id as an indication of whether the user is logged in or not. It's better not to put that in a cookie where it can be viewed or edited. So we're going to keep it in the session where it'll be safer. Then in our menu action, we can read that value from the session and set it to an instance variable. I'll have the instance variable user id, and I'll use session, and we'll have the key of user id. Let's save the file, and then let's go to our menu page, and let's use it here as well. I'll just put parentheses, and then some ERB tags to display the user id, just so we can see that we're reaching that value back. 

Let's try it out. Let's go here and launch our server. We'll open up Firefox. And we don't want the menu anymore. We want the login page. And I'm going to put in username kskoglund2, just so we can see a little bit of a difference. Click Log in. See the username there. And we see the made up ID, 1483. Now we know how to use both cookies and sessions to store data. I recommend that you use cookies for data that's not sensitive and should persist for weeks or even for months. Use sessions for everything else.

Messaging with the flash hash

In this movie, we will learn how to use a useful controller feature called the flash hash. The flash hash stores short messages in the session data. It's useful when a controller action will redirect to another action and we want to preserve a message so that the second action can retrieve it. It's for storing text strings, not Ruby objects or other data. Ruby on Rails keeps a message in the flash hash for exactly one additional request and then it automatically clears it. Of course you could store and retrieve text from the session yourself but the flash hash automates the process and makes it easier. This code demonstrates the primary use case for the flash hash. A controller action creates a new record and then redirects. The redirect will cause the browser to make a second request to a new controller action. And that second action doesn't automatically have information about what happened in the first action. But by putting a message in the flash hash, the message can be retrieved and used by the second action. In this case, the second action would probably show that success message in addition to the normal template that it renders. Flash hash messages are set by assigning a string to a key or a label. The most common label on flash messages is notice. You can choose any label you want though and you may decide to display them differently depending on the label. For example, the text flash notice could be colored blue. A flash error could be red. A flash alert could be orange and so on. If in doubt, stick with notice.

Log information to a file

In this movie, we will learn how to log custom information from controller actions. When a project is deployed, there are typically two sets of logs, server logs, and application logs. The web server will log basic data about each request as well as any errors that it encounters. The web server can see the request and the response but it does not know what happens inside the web application. The web application will log its activity in the application logs. It can provide useful information, especially for troubleshooting. The application logs are stored in the log directory. There's one log for each environment. When our project is running in development mode, we'll look for log output in the development log. You can configure the type of information that gets logged automatically and you can have different configurations for each environment. For example, you might set development to log a lot of information and production to log less. There are five log levels that you can choose from, debug, info, warn, error, and fatal. They log different amounts of information. In the first column, you can see that debug logs the most. It logs database queries, request and render details, deprecation, standard errors and fatal errors. Info is similar but without the database queries. Warn logs only errors and deprecation warnings. Deprecation warnings are triggered when you use code that's scheduled to be changed or removed. Error and fatal log only errors encountered in the web application, either all of them or just the most severe. I recommend using debug for development. I like to have access to as much information as possible when I'm troubleshooting. In production, I recommend either info or error. You don't need as much information and it reduces the potential for logging sensitive data, like personal information. Log files will grow over time. You can clear them manually from the command line with rails log:clear, or you can use other strategies to truncate or rotate the log files. On production, I usually set up log rotation in Linux but that's outside the scope of this course. In addition to the automatic logging in each category, we can also write custom information to the log files ourselves inside a controller action. This is a useful tool for troubleshooting. We use the logger object and then call a method that corresponds to the log level. We can call debug, info, warn, error or fatal. The log message is sent as an argument. The log message will be logged if the current environment's log level is at or above that level. So if we use debug to log something but the production environment is set to the info log level, then it won't be logged. The log files are inside our project in the log directory. You can see, I have one here for development.log. The configuration for the log level is set in the config directory inside the environments. Let's look at production.rb. If we scroll down, you get to one here that says config.log_level = info. I like that choice. I'm just going to add a comment right above it that gives the other choices that you could have instead, debug, info, warn, error, and fatal. And then I'm going to copy both those lines, save the file, and then let's switch to the development environment. If you scroll down this file, you'll notice that it's not listed. That's because development is using the default setting, which is debug. But I'm going to add a configuration myself, just to make it clear that it is using debug. Now let's go into access controller and do our own custom logging. I'm going to log inside the create action as soon as the create action starts. I'm going to do that with logger.info and then my message, login user. And then I'm going to put in whatever the params were for the username. I like to append something at the front of my log messages to help them stand out from any other log entries. Here, I've added three asterisks. I'm logging this at the info log level. That means that the message will be logged if the environment is set to debug or info but not if it's configured to show only warnings and errors. Let's try it. 

Let's go to the command line and let's first start by clearing the log files with $ rails log:clear . Now my log file is clear. I'll launch the web server. Now let's go into Firefox and let's go to that login page and simulate a login. Now, if we come over here and we scroll down and look at our log file, you'll see that it logged a lot of information about what was going on, some of the database queries that it was making. Here, you can see the custom log message that I added. Notice also that rails filtered out the password that was sent in with the form. That's a nice feature that's there by default. So now we see how the automatic and manual logging works in rails. Logging is a useful tool when you're developing.

Inherit common behaviors with ApplicationController

In this movie, we will learn best practices for inheriting common behaviors in our Rails Application. Ruby classes can inherit behaviors from other Ruby classes. In Rails the controllers are Ruby classes, so they can inherit behaviors from other classes too. This helps us to follow the principle of don't repeat yourself, or DRY for short. Our goal is to define code in only one place and then make it available anywhere it's needed. Class inheritance is a good way to do that. DRY code is consistent, easier to maintain and reduces bugs. Our access controller is a Ruby class that inherits from the application controller class. The application controller class inherits from action controller base, which defines the Rails controller features we've been using, like rendering, redirecting, cookies, sessions and the flash hash. Any code that's in application controller will be available to every controller that inherits from it, and by default, they all do. If you have code that two controllers will use, don't define it twice. Put it in application controller instead. Let's try an example. We have this code in access controller, which finds a username and a user ID. What if more than one action in this controller needs to use it? I'm going to copy that, and I'm going to make a separate method that both of them can call. I'll jump down here to the bottom and I'll make a private method called, get user info from session, and inside I'll just paste those two lines. It's a best practice to designate methods that are not controller actions as private, and any method below this line will be considered private. The controller class in any class that inherits from it will still have access. Now, any of our actions in access controller can call this same method. I'll copy it. Let's go back up here and let's replace this line. And let's say that the new action is going to call the same thing as well. This is DRY and better than repeating this code in every action. But what if more than one controller needed to use it? If we promote it to the super class or parent class application controller, then all our controllers can access it. So, I'll just take these lines right here and I will cut them, save the file. Let's go to application controller and let's just paste those in right here. Now, all our controllers have this same method and they can call it. Let's add another method as well. I'm going to add a new one here. I'm going to call it, logged in, question mark, and it's just going to check to see whether users logged in by checking to see if that session ID has been set. So, if it has been set and it's present, then we'll know that the user's logged in. Now, let's use that in our access controller. It inherits from it, so it has the ability to use it, and let's put it in our new action. If a user goes to the login page, while they're already logged in then let's send them straight to the menu. If logged in, question mark, then let's redirect to menu path. We should also take a moment to add a log out button to our project, or else we'll never see our login page again, once we log in the first time. So, let's go to our menu and let's add one right here. I'm not going to add a link to. I'm going to use button to, which will be very similar, but it works well with a delete action. So, I'll make the text log out and the button will link to log out path, and it will use the method for delete. If you remember in our routes, we have log out defined as being delete. So, we need to do it that way. And then, let's close our ERB tags, and then, we also need to perform the log out. So, here in the destroy, the most important part is that we have the session user ID and that we set it to nil, so that it's no longer marked, but let's also go ahead and add the logger info to the top and the cookies we'll add down here, and let's go ahead and put in a flash notice as well. So, this will just say logged out and the username will be set to nil and the logger info, we're going to say, log out user, and instead of using the prams here let's use the cookies for username before we clear it. Okay, now we're ready to try it out. Let's go and launch our server, and then, let's go to Firefox and let's go to our login page. Now, we are logged in at the moment. So, it used that method right here, logged in, which was defined in application controller, and then it redirected us to the menu page. Now, if I log out, now it takes me to the login page and it does not redirect me this time. Now, we know how to inherit common behaviors from application controller and we can keep our code well organized and DRY.

Use filters to call methods automatically

In this movie, we will learn to use controller filters to call methods automatically. Controller filters execute code before or after a controller action, they can filter requests before allowing actions, they can remove code repetition, or perform basic housekeeping tasks. There are three controller filters, before_action, after_action, and around_action. As their names suggests, before_action executes a method before the action takes place, after_action executes it after the action, and around_action runs code both before and after. The before_action is the filter you will use the most often. Over years of working with Rails, I've only used after and around filters a few times. Our application controller has the get_user_info_from_session method, but it's not being called automatically. Adding before_action, followed by the method name as a symbol, will always call that method before any action. 

I also want to give you an example of how the around_action works. This one is calling a method called buildup_teardown. Inside the method, it performs some code at the start, and then there's the word yield, yield is where control is yielded over to the action. When the action is done, the code below will be run. 

Controller filter methods should be declared private or protected since they're not actions, and any render or redirect that takes place in a before filter will prevent the action from executing. For example, if the user's not logged in, you might redirect them to a login page, and never execute the action. You can specify which actions use a filter with the only or except options, and an array of the methods to include or to exclude. Filters are inherited, but you can skip those inherited filters by using skip_before_action, skip_after_action, and skip_around_action. In our access controller, we're calling get_user_info_from_session two different times here. Instead, we could use a before filter. I'll just copy that and come up here, and do before_action, and then a colon for a symbol, and then the method name. Now I can remove these lines, because it will be happening automatically. Now I can have it take place just for the menu and new actions, or I can make it take place for all of them. Or if I want to, I can take this, and I'll cut it, let's save it and go to our application controller, and I can paste it in here. And now every controller and every action that inherits from ApplicationController will also automatically call get_user_info_from_session. So, if it's set in the cookies in the session, we'll have instance variables username and user_id available throughout our controllers and views. Let's add another method here. This one's going to be confirm_logged_in. And it's going to use the method right above it, and say unless the user is logged in, then we're going to redirect them, and let's also show a flash notice at the same time. The flash notice will say, "Please log in." And we will redirect to the login path. Now let's think about how a before filter like this might work. Where would we put it? We could take it and put it up here, and have before_action, get confirm_logged_in. This would make it so that every single controller and every single action would check to make sure the user was logged in before it let them access that action. We might want most of the pages to be like that, but we definitely don't want all of them to be, because, for one thing, we want to make sure that they can get to the login page and log in, and currently, those pages would redirect too. There are a few different approaches you could take. You could not put this in ApplicationController, but instead put it in each controller one by a time, the ones that are supposed to confirm the login, and we could use something that says except for new and create. Or we could use skip_before_action, and change this from except to only, so it will only skip it for those two. There's no right answer here, it just depends on how your application ought to work. So, let's save it, and let's try it out. rails server. We'll go into Firefox. Now I'm on the login page, let's go to the root of the website first. It took me to the login page, that's because I'm not logged in. kskoglund. Now I'm logged in, I'm on the menu page. Now if we go to the root of the website, no problem, it let me through, it let me come to the task page. Back to menu. If I click Logout, I'm on the login form. But again, if I try now to go to tasks, you see it just takes me to the login page. All those pages are now protected unless the condition inside that confirm_logged_in method is met. We now know how controller filters work, and we've seen a classic example of where filters can be helpful in a Rails project.

RENDERING VIEWS

Avoid double render errors

In this chapter, we'll focus our attention on rendering views. And we'll start by talking about double render errors and how to avoid them. 

A controller action must choose the way any request will be handled. When all the code in the action is done, the action must either render something or redirect to a new URL. Those are the only choices, and it can only choose one. 

Render does not immediately render a template. Instead, it sets the template that will be rendered. And redirect does not immediately redirect. It sets the value and the response to the browser. Neither render nor redirect terminate the action. If we call render or redirect twice in an action, we get an error. 

In this code, if the user's logged in, only render menu will be called. But if a user's not logged in, it will prepare for a redirect and then also call render. Rails will raise a double render error and explain what went wrong. It tells you that you tried to call it multiple times in one action. You can only do it once. And it tells you that they don't terminate the action. So if you want to exit an action, you need to do something like redirect to and return. 

That's one solution. Another solution is just to write your code so that the render and redirect are only encountered one time. Here, I've used an if else clause to ensure that it will only run one or the other, but not both. Or you can do as they suggest and use a return after the render or redirect to stop further execution of any code inside the action. This code would redirect and then immediately exit the action and send the response. Be sure to use the keyword, and, before return. 

Do not use a double ampersand as you might with a true or false logical statement. Every action also has an implicit render. It will render a template with the same name as the action by default. But that implicit render can be overridden without raising any kind of double render error. 

In our example, we were explicitly rendering the menu template in the menu action. 

Another solution would be just to remove that line so that relies on the default behavior to find the template. And then it would work without error. Once you remember that you can only render or redirect once per action, you won't run into double render errors very often.

More options for rendering content

There are many options for rendering content in Ruby on Rails. The most basic, we've encountered already. An action can render its default template, or its code can specify a different template, and we also learned to render partials inside those templates, but let's look at some of the others. 

You can render plain text or HTML text. The response will include only that text. These sort of assume that the response will be short. Otherwise, you would use a template. You can render JSON. You can either write out the JSON as a Ruby hash, or you can provide an object, and Rails will call a toJSON method on it. You can render a hash or an array as XML. Rendering JSON or XML is useful when the controller action is returning data for an API or responding to an AJAX request that will just update a small part of the current page. You can also just return success or failure. This returns plain text for OK but more importantly, it has a status code of 200 for success. 500 would indicate an error, and 404 is used for not found. There are many others. If we left off the plain text, it would render the normal template and just change its status code. So if we really do want to just send back a status, we need to include some kind of a string. You can also render a file. This is an actual file and not an ERB template. Render file will render the file in the browser as is. If you want the user to download the file instead, then send file is a better choice than render and finally, you can render to a string, instead of rendering in the response to the browser. You can assign that string to a variable, parse it, edit it, store in a file, whatever you want to do with it. Let's try these out. I'm going to put some examples inside our menu action. Now, they're commented out at the moment. If we were to just render the menu as it is, we know we would get the default template. Let's see that behavior. I'm going to launch the Rails server, and then let's go into Firefox, and let's make sure that we're logged in because if not, we won't be able to get to our menu page. All right, so I'm just getting the default page now, and we know if we un-commented this line, it would do the same thing. It would just be explicitly rendering the menu, instead of letting the default take place. Let's try rendering the plain text. We'll save that and come back and reload this page, and you see it says, "Just render text." We can un-comment the HTML line and try that one. You see we get back HTML. Let's try the JSUN. Notice that I'm rendering JSON, and I'm just giving it an object. The first task that's in the database. So it goes to the database, looks up the task, and I'm using that object and rendering it back. This might be in response to like an API request. You can see that it rendered the JSON, and Firefox gives me a little bit different view of it but by default, the toJSON method gives us back all of the attributes for that object and the values that go along with them, and then if we were to go to render XML, you see I've just got a simple array, dog, cat and mouse. Let's reload the page. You see it turns that into XML for me, and I can render just the plain status. We won't actually see the status code. We just see the text, but the code is right here. We see it in the console, and you could also see it in the browser inspector as well, and we could change that to different numbers to see how we can change the status code. Let's try a few that work with files. Let's first create a path to a file. So I've got a path to 404 here, and I'm using rails root. That's the root of my project, and I'm joining that with the directories that are inside there and inside the root of my project, inside the public directory, there's a file here called 404.html, and that's the file that I'm going to use just for demonstration purposes. So we can just simply render that file, and it's going to be path to 404, come over here, reload the page, and we get, the page you're looking for doesn't exist. That is the thing that I'm rendering, right? It's not telling me that the page doesn't exist. (chuckles) That's the page I'm actually showing the user. I could instead change that to be a send file. Let's do that here. Do send file, path to 404, and that's going to ask the user if they want to download it, right? So here it downloaded it for me, and let's comment that one out, and let's try another one, which is to make a string out of it. So we'll have a string which is equal to render to string, and we'll put in the file with the path to 404. Now I have the string. What do I want to do with it? I could parse it. I could, you know, search and replace things inside of it, whatever I wanted to do. Let's just, for an example, let's just use our logger in but debug the string, and that'll just take that file and dump it to our log. Let's come over here and reload it. All right, now we solved the default template, but if we come over and look at our log file right here. Let's scroll all the way to the bottom. You'll see there it is. It actually rendered that string to that log file. So I'm going to comment all of these out because what we want is the real actual menu instead, but these will just be placeholders that you can use as reminders of the kinds of things that you could be rendering. Let's just go back one more time and make sure we get our regular menu page. These examples show some of the other options for rendering content besides just rendering the view templates.

Use layouts for shared templates

Layouts are an indispensable tool for giving all the pages and web application a similar look. The pages can share the same structure, the same header and footer, the same navigation, and more. Layouts help to keep our code dry. A layout is a template file that contains the framing HTML for every page, and also an indication for where the custom content for the template should be inserted. We do that by putting the keyword yield inside a set of erb output tags. Rails will render this layout file, and when it reaches yield, it will then yield control to the template that's been set in the controller action. And then when that template is done, it will come back to this layout to render the rest. 

You can configure the layout to use with every action in the controller with layout, followed by the name of the template. By default, the layouts are stored in the app views layouts directory, and the file name ends in .html.erb, because we want Rails to process any erb code that's in that layout. Different controllers can have different layouts. 

You might have one layout for public facing page and another layout for the admin area. They might have a different page structure, load different style sheets, and use different JavaScripts. And you can use accept and only to limit the layout to certain actions. And this example, most actions would use the admin layout, but the access log action will use the report layout. We can skip the layout completely with false, or you can change or skip the layout on a per action basis, using render with the layout option included. 

Let's take a look. So we're going to find our layouts inside app, inside views, inside the layouts directory. And we want to look at application.HTML.erb that Rails gave us by default. You can see that Rails has included some helpful bits for us. We aren't going to worry about those now, but notice the erb tags here with the keyword yield. That's where the template will be dropped in. So right now, anything that's using the application layout will use this shared common HTML. If right above yield, we were to add some code, that would appear on every page that uses this layout. I'm going to paste some HTML right above it for a header. Let me just indent this a little bit. You can pause the movie to copy it down, or it's also included inside the exercise files. Now this header will appear on every single page, and it will show the name, task manager, it will show whether the user is logged in or not, if they're logged in, and give them a button to log out. I can do the same thing down below yield, I'll paste in a footer. So now they can all have a common footer. Everything will have the exact same thing, and I've just got a copyright with the year right there at the bottom. And let's go ahead and take this yield and let's wrap it in a div tag. I'll give it an idea of content. (typing) And let's also give it a style that has a min height of 400 pixels. Let's go over and just check this out. So let's launch the Rails server. Let's go to Firefox, and let's reload our menu page. Look at that. We've got the header at the top, we've got the footer down at the bottom, and we've got the content that gets rendered in between. If we click on Manage Tasks, look at that. It picked up those same changes. So that's throughout our application. Everything that's using that default application layout is going to be getting these same changes. Now on our menu, we already had the user and the logout button. We can now take those away. 

We also had a flash notice that was showing at the top. It would be great to have that on every single one of our pages. So let's take that out. And instead of repeating it on every single page, we can add that to our application. We could just put it right in here, but I also know how to make partials. So let's put it as a partial. We'll have render, partial, and I'm going to call it layout/flash. That's going to be the partial. And then I will come over here to the layouts directory, and I will make a new file, which I will call _flash.html.erb. And then let's paste that code in there. And that'll just show our flash notice at the top of every page. We go back now and just try that out. Let's log out and then log back in. (typing) Look at that. It's at the top of all our pages. And when we log out, right, we see that it says logged out at the top of the form page, which it didn't used to do. (typing) And now we have it back here again. Now we didn't explicitly put that at the top of the access controller, but we could. So let's just add that. This will use the application layout, but it's also the default if we don't specify something different. You can see how layouts are a useful tool for managing the look of your webpages.

Capture content for later use

In this movie, we'll learn to use another useful feature of templates: the ability to capture content for later use. To do that, I'm going to introduce you to two Ruby on Rails helper methods, content_for, and content_for? with a question mark. The first method captures content and assigns it to a name. That content can either be a string or a block of code. And the second method will check to see if any content has been captured for a name. On a page template, we can use content_for, and pass an assemble to use as the identifier name. Then in a code block, which is everything from do to end, is the content that's going to be captured. This content will not be output immediately. It'll be held in reserve until other code calls for it. You can capture different content using different identifiers. If you use the same identifier more than once, the content will be concatenated, not replaced. We can use the captured content by yielding with the content identifier. For example, this is a layout that has a yield in the HTML head, that asks for any stored content for script. The content captured on the previous template would be dropped in here. It may seem odd that this layout won't actually yield to the viewed template until a few lines further down, but Rails does some pre-processing that makes this possible. Let me give you another example. Here's an HTML layout that sets the HTML title to any text captured for title, or default text if none is found. And then, it will check for content captured for sidebar, and display it with HTML tags around it, if it exists. Let's try it in our project. Let's go back to our application layout, and let's add a yield for JavaScript content. We'll do it right here at the very end. I'll put ERB tags that output anything that has been stored for script. Now, any template that uses this layout can capture JavaScript, and it would be output in the HTML head. Let's try that by going to our About page that's over here in Main and About, and at the bottom of this page, let's just add content_for(:script) do and end. Now everything that's inside that code block, from do to end, is going to be captured. So let's put in some script tags, and inside those, we'll just put alert that says, "Welcome!" Now, before we try it out, let's go back to our layout and let's add in another one here in the title. So we have Task Manager. I'm going to put some ERB output tags immediately after it, with no space. And then, it will output a separator that is " - " + yield whatever has been captured for a title, if content_for?(:title) exists. Now, the reason I have this "if" here, and I'm not just letting this return nothing, is because I want to suppress this divider if there is no title to be shown. Now we can save that and jump back to our About page. And at the top of our About page, let's just capture a page title. So we'll have content_for(:title), and this time, instead of using a code block, let's just use a string. So we'll just call this 'About.' And I'll copy this and let's go to our Menu page. And at the top of the Menu page, we'll put one for 'Menu.' And we could do this for every single page in our site. It'll set the title of the page that's going to be in the HTML layout, but it will do it from the template. If we try this out, let's go to our command line and launch our server. Now we come here, let's go to our About page. Here's our welcome message. And you see, it says, "Task Manager - About." Click back to Menu. It says, "Task Manager - Menu." And if you were review source, you would see that it actually had added those in the HTML at the places you would expect. It's useful to be able to capture content in the template, which is used in a different area of the page.

INCORPORATING ASSETS

Add stylesheets to view templates

In this chapter, we will learn to work with assets in Ruby on Rails, beginning with style sheets. We can work with style sheets two ways. The simplest is to put a style sheet in the public directory of the project and then add a link in the layout that refers to it. Or you can use a feature called asset pipeline. 

Using the asset pipeline has several benefits. It will concatenate several style sheets together and pre-compile the style sheets. This compresses and minifies the files, removes white space and comments and allows writing styles in other languages like SAS. And the asset pipeline does asset fingerprinting which helps browsers keep cached assets up to date. If the file contents change, the fingerprint changes and the browser looks for an updated file. 

If you use asset pipeline, style sheets are kept in app/assets/style sheets, and the file names should end in .css. 

To use the asset pipeline, there are four steps to follow: 

 - First, the asset precompile list needs to include a manifest file. 

 - That manifest file will list all of the style sheets that will be processed and concatenated together. 

 - Then we can add a style sheet link tag to our layout. 

 - And finally, if you're deploying the site, you'll need to tell Rails to process and concatenate all the files into one. 

Let's look at these steps in our Rails app. 

The first step is to make sure the asset precompile list includes the manifest file we want. That's located inside the config directory, inside initializers and assets.rb. You can see right here, precompile additional assets. It tells us that by default, application.css will already be included. But if we had a different manifest file that we wanted to use, then we would uncomment this line and make sure that we added it to this list. For example, they've included a manifest file called admin here for you already. Now, we're not going to do that. We're going to use the default one so we can leave this alone. But that's step one, to make sure that we have a manifest file listed in the assets precompile list. 

Step two is to go to app, assets, style sheets to find that manifest file and make sure that it lists the style sheets that we want. This looks like it's one big code comment in CSS but these lines here that have equal signs are actually instructions to asset pipeline. 

The first one tells asset pipeline to include all CSS files that are in the current directory. 

Right now, there are no others, but we can add one. Let's add a new file here and I'm going to call it structure.css. Now, that file will be included because of require tree. Require tree will include every file in alphabetical order. Then require self will also include any CSS that's included in this manifest itself, anything that's below the code comments. Here's another example of a manifest file. Instead of using require tree or require self, it is loading individual files by name in a specific order. Some files are in a sub-directory called public. This makes it easy to maintain specialized style sheets that will be assembled into one. So we've taken care of steps one and two. 

Step three is to go to our layout and make sure that we're loading in the style sheet, using stylesheet link tag and we're loading in the application. That is the name of the manifest file that's going to be compiled, the end result of all those CSS files being put together will be called application. (Don't worry about this code related to turbo links. That's a feature of Rails that allows pages to load faster.) 

Let's move some of our inline styles that are here into our style sheet. I'm going to paste those in. It's the same thing that we had in there. I'll save the file and we can go back and we can now remove all these inline styles. And there's one here and one down here in the footer. 

So now instead of having inline styles, they're all inside structure.css which should be compiled and loaded for us to use. Let's go over here and try it. We'll launch the server and then let's go into Firefox and let's just reload our page. And you can see, we still get the styles, even when we switch to different pages. It's loading in those styles that are all coming from the style sheet. So we have a manifest file that lists the style sheets and a layout that loads the compiled style sheet. 

In development, we don't need an extra step to compile them. Rails handles it for us. But for production where speed really matters, we need to add a step. To precompile, first make sure that the environment is set to production. Then use the command, 

 *** bundle exec rails assets:precompile ***

This will pre-process the files and cancatenate them into a file according to each manifest. If you're using a tool to help you deploy like Capistrano or a hosted service like Heroku or Engine Yard, they include scripts to do this for you automatically. Using style sheets with asset pipeline can require a little extra configuration but it has big benefits.

Use static image assets

In this movie, we'll learn how to work with static images in our Rails projects. What I refer to as static images are images that are stored with our project code. They don't change unless we change our project and deploy it again. Static images might include logos, buttons, icons, or other elements of the site's user interface. Dynamic images, on the other hand, would be images that are uploaded after a project is deployed. They're typically stored on the server in a file system or in a database and they can be updated. Dynamic images might include product images, or user submitted photos. Dynamic images are beyond the scope of this course. If you want to learn more about them, you can read up on a Rails feature called, Active Storage. We will focus on static images. There are two ways we can work with static images. The simplest is just to put images in the public directory, inside an images directory, and then use a simple HTML tag to reference it, or we can use the asset pipeline, like we did with style sheets. The asset pipeline makes it easy for helper methods to work with our images. It performs asset fingerprinting by adding a hash to the image file name. Then if the image content changes, the file name changes and the browser will look for a revised image. We just need to put our images in app/assets/images. Then when we want to refer to those images, we won't use a simple HTML tag. We'll want to use a Rails helper because, remember, asset fingerprinting will change the name of the file, but rails will handle that for us if we use image_tag and then provide the name of the original image. You can add options like size, alt, width and height to customize how it appears. Let's try it out. In the exercise files, I've added an image asset to app assets, images. It's called taskmanager_logo.png. Let's add it to the top of every webpage, where right now we have the word task manager, let's replace that with an image of the logo. So, I'll delete the text and I'll use ERB tags and inside them I'll use that image tag helper, and the first argument to the image tag helper is the name of the original image, which is taskmanagerlogo.png. Then I can provide any options I want. I'm going to set the height to 25 and add an alt tag for task manager logo. I'll save the file. Now, let's take a look. We'll launch the server and then we'll go to Firefox. You can see what it looks like before when it just has simple text. Now, we'll reload the page, and now we get an image instead. If we go up here to our tools and choose web developer tools to look at the page source, in the header, you'll see the image tag that it created, and you see that it put it in the assets directory, and you can also see the asset fingerprinting that it did at the end. So, the file's not called task manager logo anymore. It's task manager logo with a long string of letters and numbers appended to it, but Rails handles all that for you. All you have to do is use the image helper tag. We can also put images inside a link. For example, we could make a link to the homepage. So, when you click on the logo, it takes you back to the menu. All I have to do is use link to in front of it, and the first argument instead of text, will be the image, and then after that, I'll put the path. I'll put it for menu path, save it. And we come up here and we can reload the page. And now, when I click on it you can see it takes me to the menu. Even better I think, is a nice little trick. I'm going to undo the code that I wrote, and I can make this link to up here, and I will use a block format for it instead. Now, this we don't normally do. Normally, you just put the link text in there, but it does accept a block, and so everything from due to end will be what is linked. So, I don't need a first argument anymore for my link. I just need the second argument, which is menu path. Let's save it. Let's come back over here and reload it, and let's go to manage tasks. We click on task manager, takes us back to the menu. I think this is a little cleaner when we're wrapping images inside links. We've managed to use asset pipeline to put a static image on our page, and we also learned how to wrap a link around it.

Use images as CSS backgrounds

Sometimes we want to use an image as a CSS background and not just in an HTML image tag. Rails has helper methods to assist you if you're using the asset pipeline. This is how to add an inline style with a background image. You can use this in Rails. However, it won't work well if you're using the asset pipeline. The file won't be called logo.png. The asset pipeline will copy the images to a new location and append a fingerprint to each file name. You won't know the name ahead of time, and it will change if the image content changes. Instead, you can use the helper method image path and Rails will provide the correct path and file name. It's similar to image tag, but it only returns the path, not the entire HTML tag. If you want to set a background to an asset pipeline image in your style sheet, then you have two choices. First, you can add the .erb file extension to your CSS files. When Rails compile them, it will evaluate the erb that's inside. That will allow you to use the same image path helper as we did in the HTML template. Or you can enable the Sass gem, and use the image URL helper that's provided with it. In Rails versions 5 and 6, Sass was enabled by default. So this was a common way to do it, but in Rails 7, you must enable Sass to use it. Let's try these in our project. Let's add a gradient as a background image to the header and the footer. I've included a gradient image in the exercise files in app, assets, images. It's called gradient.png. First, let's add it as an inline style. We can do that right here in our layout. So we have our header. We'll just add style equals background image, URL, and inside that we'll have single quotes. And then we'll put our erb tags where we're going to output the value that image path gives us. So image path for gradient.png. All right, let's save it. Let's try it out. We'll launch our server. We'll go over here to Firefox. Let's just reload our page, and you see it switched to a gradient image. It starts out darker, and it becomes lighter when it gets over to this side. Okay. Now let's add it to our style sheet. I won't demonstrate how to turn on Sass, but I will show you that you can enable it by going into your gem file and then finding the Sass gem right here. It's called sassc-rails. And if you just uncomment this line, and then go to your command line and run bundle install, then it will install the gem. That's all there is to it. Instead of using Sass though, I'm going to change our style sheet up here so that its name ends in .erb. That will cause it to be pre-processed by erb to give us a CSS file. Now I'll close up the gem file. Let's go back to here. Let's take this inline style and remove it. And, instead, let's come over here to structure and right below the background, we'll put in the background image with the same path that we had before. And I'll just take that same line and come down here and do it in the footer as well. So let's save it. We'll go back. Let's reload the page, and it worked. Both our header and our footer now have our gradient image. That's how you use images as CSS backgrounds.

WORK FASTER WITH HELPERS

Text helpers

Ruby on Rails includes a variety of helper methods to perform common web development tasks. In this chapter, we'll look at some of the most common ones, starting with text helpers. I want to show you word wrap, simple format, truncate and pluralize. Word wrap adds line breaks to a long string of texts at certain intervals so that it never gets too wide. It tries to break between the words. The default width is 80 characters, but you can change it. You can also set the break sequence to use. By default that's going to be a backslash N. If you output the backslash N to HTML, it will ignore that line break in most cases. You can replace it with a different break sequence, or you can use our next helper method, simple format. Simple format uses simple formatting rules to convert a string to HTML. It will wrap the text in HTML paragraph tags, then each line return will be converted to a BR tag, and consecutive line returns will start a new set of paragraph tags. The truncate helper method will truncate a string to a specified length, and it will add an omission string at the end. The omission string is included in the character count. So in this example, it will return 25 characters plus three periods at the end. The pluralize helper accepts a number and a word as arguments. It will pluralize the word based on the number. In this example, it loops through the numbers zero, one and two. So you can see how the output changes. Rails is smart about its pluralization rules too. It knows that the plural of person is people, and it knows that the plural of ox is oxen. If you have a special case that it doesn't know, you can add it to the inflections file in the config directory. Let's begin by adding a new task that has a long description. So I'll go to rails server, launch Firefox, go to my tasks. I'll add a new task here, and I'm going to call this task Mow lawn and for the description, I'm going to paste in some text here, so you don't have to watch me type it, but I'm basically just typing in a whole bunch of text about the process of getting the lawn mower out and getting the yard mowed. I'll click Create Task. Now that we have that, if we click Show, we see that long bit of text, and it flows all the way to the end of the div right now, the width of the window. So let's change that now. Let's go into views, tasks, show and down here where we have the description, let's use word wrap on it and got to put a parentheses around it, and let's wrap it to a line width. We'll do 40. Now, that will give us backslash N line returns by default. Let's save it, and if we look at that, you'll see it didn't change anything. If we also use simple format with it, then it will respect those line returns because it will turn them into HTML, and now we get what we expected. Now let's say that we go back to our list view, and we want to put the description on this page, but obviously we don't want that long bit of text. So let's go here and let's add it. So we have Completed. Right below that, we'll put in one that says Description, and I'll copy name and right below completed, this is going to be the description also and just to see what that looks like. You see it's very long. Let's instead use truncate with that so that we only get a part of it. So truncate the description and for the length, let's use 30. So we'll save it, go back here and reload it, and you'll see it truncated and put ... at the end. Now, for the last demo, for pluralize, I've gone ahead and added a file to the exercise files. It's inside of views, layouts, error messages.html.erb. It's so that we can display error messages that happen on forms. So we'll list the error messages by looping through them but notice up here, it has a summary where it pluralizes how many errors there are. So we pass in the number of errors with the word error to pluralize, and we should get back the right text for it. Now, I've got that at the top of my forms. I'm rendering that at the top of the task form and the categories form. So if we go here to add a new task, it's right up here, but we don't have any errors to show. So let's make it have some errors. Let's go to the new, and let's just forcibly add some here. Obviously, we won't want this to stay, but we can use it to try things out. Task.errors, add an error on name, save it, reload it, "1 error," singular, "prohibited this record from being saved." Let's copy that. Now let's add an error on description. Come back, reload the page, "2 errors," plural, "prohibited this record from being saved." Now we're going to remove those 'cause we don't want to keep our errors in there, but you do get the idea of how pluralize works. A few other text helpers that might be useful are truncate words, which truncates a string after a given number of words. Highlight looks for a key phrase, and then it adds a string around it so that you can highlight the item using CSS. There's excerpt that looks for a key phrase and then returns an excerpt of characters around that text. There are many more examples, but you can see why these helper methods are real time-savers when you're developing.

Sanitization helpers

In this movie, we will learn about sanitization helpers and why you need them. We need to sanitize content to protect the web application from malicious code. A common example is cross-site scripting, in which a hacker submits a string that will make the browser run code we didn't intend. It might redirect users to another website, or it might steal cookies or log in information. This simple example that opens a popup alert is a stand in for any malicious JavaScript. If we output that string on one of our templates, the browser would run the JavaScript code as if we'd included it in our code on purpose. We also want to sanitize content to prevent adding HTML to the page that may break the layout or apply formatting we don't control. This example adds some formatting and has an extra closing div tag that could break our layout. We need to treat user submitted content with caution. That data may be from the URL, from a form, cookie data, or from information previously stored in a database. Sanitization helpers are tools to neutralize the majority of these threats. HTML escape or just H for short, will escape the HTML tags in a string. It replaces the open and closed tag characters. That's the less than and greater than sign, into their HTML entities. Recent versions of Ruby on Rails will HTML escape all ERB output by default. There's nothing extra to do. Rails handles this for you. There will be times when a string contains HTML that you want to preserve. You will need to tell Rails not to escape the HTML in these strings. The raw helper will suppress the default HTML escape during the ERB output. Or you can mark a string as always being safe by calling HTML safe on it. This will also suppress the HTML escape and you won't need to use raw. If you modify the string later though, Rails will consider it unsafe again. Another approach is to remove all of the link tags in a string using the strip links helper. In this example, you can see it will remove the link tag but leaves in the strong tags. Or you could remove all of the HTML tags from the string using the strip tags helper. Here, it removed both the link tag and the strong tags. JavaScript is also vulnerable to malicious user data. In this example, notice that the text includes extra single quote characters. When it's dropped into a string for JavaScript to use in a warning message, it changes the meaning of the code so that a second script will run. Escape JavaScript, or just J for short, will escape the string so that it's safe for JavaScript. In this case, it added back slashes in front of the single quotes so they become harmless text. JavaScript sanitization isn't automatic, so it's up to you to remember to escape it. Let's try this out as an example. We had a bit of JavaScript in our main template on the about page. We put in an alert here. I'm going to just paste some code above it here. And I'm going to remove the one here that just has the script tags. Here's a version that uses a helper called JavaScript tag. It just puts the script on either side of it and then it has the JavaScript inside and you can see it drops in the name into that string that its going to use for the alert. And here's the name up here. I've just got it hard coded in. Let's see what that looks like. Let's go to rails s, and launch Firefox. We'll go to the about page and there it is. Welcome, Kevin. That's the desired effect. But if someone were to submit a malicious string so that it was Kevin and then had a single quote and then some more JavaScript code there, let's save it, let's go back and see what that looks like. Reload the page. Welcome, Kevin. Oops, it's missing the exclamation point this time. Gotcha. There it goes. So this is the second code. This is whatever the hacker intended and not what I intended. So the solution is just to use J around anything we're going to drop in there to escape it for JavaScript. Now, when we go back and we reload the page, it just becomes harmless text. We see the hackers code but it didn't actually turn into code. It's just text. And I'll just comment this back out before we leave it so that we have name equals Kevin, as we intended. Sanitization helpers are useful for protecting your website from malicious data.

Number helpers

Ruby on Rails includes mini methods designed to help format numbers. There's number to currency, number to percentage, number to rounded, or number with precision is an alias for it, number to delimited, or number with delimiter, number to human, number to human size, and number to phone. They all take a number as their first argument. You can provide a hash of options as a second argument if you want to override the default settings. Most take a few standard options. Delimiter is the character for delimiting the thousands and the default is the comma. Separator is the character for the decimal separator and the default is the period. Precision is the number of decimal places to show the default value varies between the methods, but it's typically two or three. Let's take a closer look at number to currency. It converts a number into currency using the dollar sign and two decimal places. If you wanted to use a Scandinavian krona instead, then you can add options to use kr and reverse the order in the format string. Number to percentage by default uses three decimal places and adds a percent character. You can change the precision or the separator. Note that it does not divide the number by 100. It's up to you to do that before you format it. Number to rounded will round a decimal to three decimal places. You can change that precision. This method is also alias as number with precision. Either name works the same. Number to delimited adds delimiters to a number. It adds a comma after every three digits starting from the right. You can change the delimiter if you don't want a comma. And this method is alias as number with delimiter and they work the same. Number to human converts a number to a human equivalent using words like 123 million. You can also change the precision that it uses. Number to human size is useful for describing computer storage. It will convert a number into kilobytes, megabytes or gigabytes and you can adjust the precision. Number to phone will format a number as a phone number with a dash as the delimiter. There are several other options you can include, the delimiter but also the area code, the country code and the extension. These number helper methods are straightforward to use but they're big time savers that address common development needs and save us time and headaches.

Date and time helpers

Ruby on Rails includes helpers for working with dates and times. Let's look at a few of them. There are methods to help with time calculations, second, minute, hour, day, week, month, year, as well as the plural forms of those. You append them to a number and then you can do calculations. Here's an example. Time.now returns unix timestamp for the current time which is the number of seconds since 1970. We could add and subtract seconds from that time in order to find a new time. The helpers do the same thing but they make our code clearer which reduces the chance of mistakes. It's very readable. Time.now plus 30 days minus 23 minutes. If we're working with the current time, there are two other useful helpers. We can use ago to return the current time minus a number of seconds. So 30.days.ago, or we can go in the other direction and use from_now to return the current time plus a number of seconds. Both are very readable. There are methods that help with relative time calculations. You can jump to the beginning of the day the week, the month, the year, yesterday, last week, and so on. Rails will calculate the relative time for you. For example, we can start with any date time object and jump to last year, to the end of the month, and to the beginning of the day. That would be a difficult calculation to do on your own. But Ruby on rails has it built in. And there are methods to help with time formatting. We can use string f time or string formatted time and provide a format string as an argument. This method and its format strings appear in many other computer languages. So you may have used it before. These are commonly used format characters. If you use it often, it can be helpful to make a cheat sheet or to take a screenshot of this list. Rails also include some standard formats. You can call to_formatted_s on a date time object and include one of the format symbols. Or you can use to_fs for short. For example, long returns the string that you see here. Here's several other built in formats. DB is useful for formatting a time for an SQL database. Number returns it without delimiters. Time returns only the time portion. And short, long, long_ordinal, rfc822, and iso8601 give you common formats. You can also define your own formats in config initializers. We were displaying a couple of times in our application. Under tasks for show down here we have the created time and the updated time. And we're just using the default for each of those. Let's change those to use to_fs for formatted string and we'll just use long. I'll copy that. We'll paste it here. And I think I did the same thing in categories, show and let's put it there as well. Now let's go take a look. We'll launch our server and open up Firefox, manage tasks. Let's look at our first task show, and now we see that that's been formatted in the long format. These date time helper methods take a lot of the pain out of calculating and formatting values for web application.

Form helpers

Ruby on Rails has many form helpers that we can use. First, we need to understand the two basic types. The first helper is form_tag. Notice that its first argument is the URL where the form will be submitted. The second helper is form_for and its first argument is an object. Rails will determine the URL to use based on whether that object has been saved to the database or not. Both of them have a code block in which the form inputs would be listed. But the second one has a block variable 'f', which represents the form and allows the inputs to use the attributes of the object to populate the form values. That's why the second one is called a form builder. 

In general, if a form is providing information for a model, you'll want to use the second one. For example, here are three different flavors of a text_field tag helper. The first is a simple input tag with the attribute of name and a value that we provide. The second version takes an object as its first argument and then the attribute. We don't need to provide the value because the helper will use the object's attribute for the value. And the third is the form builder version of the text field. We need the 'f' block variable that form_for gives us. It already knows the object so we only need to give it the attribute as an argument. 

Try to use form_for and the third version whenever you can. But there will be times when the other ones are more appropriate. For example, our project's login form uses form_tag. Rails provides many form input helpers, there's text_field, password_field, text_area, radio_button, check_box, select, hidden_field, date_field, time_field, datetime_field, file_field, label and submit. And there are many more. 

But these are the ones that you'll use the most. All of them come in two flavors. There's text_area as well as text_area_tag, check_box and check_box_tag, and so on. There are a couple of quirks you need to know about. 

Here's a form for editing a task which uses form_for and the form builder type tags. The first input is a text field for the name along with options to set the size and the maximum length. Next is a text area for the description that includes the size of the text area which is 40 columns wide by five rows tall. You can also specify those separately using calls and rows. Next, we have a radio_button. You need one radio button for each choice. Both inputs are going to be for content type, one for text and one for HTML. The label text the user will see must also be provided separately. Next, we have a checkbox input for visible. In HTML, check boxes submit a value if they're checked and submit nothing if they're not. That makes it challenging to tell whether box is unchecked or just wasn't on the form to begin with. The check box helper solves this by adding a hidden field with a value of zero right before the check box. If the check box is not checked, the hidden field value will still be sent. And the controller action can tell that it was on the form, but was unchecked. Finally, we have file_field which provides an input to select a file. When you use it with form_for and a form builder tag, it will automatically set multipart true on the form which HTML requires for uploading a file. 

There's also a select_tag helper that works a little differently than the others. A select_tag allows you to choose from a list of options. If we use the select_tag version, then we need to create the HTML for that list by calling options_for_select. The first argument is the choices and the second argument is the value of the currently selected item if any. If we use the select helper on a form builder form, then we don't need to use options_for_select. We can pass in a range, an array, a hash, or an array of arrays and the helper will create the HTML for the options for you. Let's look at the forms in our project. Our login form at views, access, new is going to use the form tag helper here at the top. And you see it provides the URL, the access path that it's going to use. It also uses label_tag, text_field_tag, label_tag, password_field_tag, and submit_tag. 

Now let's jump over to our view for tasks new. You can see that it uses the form_for helper and passes in an object. And here's that block variable 'f'. Here we're rendering the partial for the form and passing that 'f' off to the partial. If we take a look in there, you'll see that it's using the form builder versions of text_field, check_box and text_area. These will look to the object's attributes to get their values. This is a good place for you to experiment and try working with radio buttons, selects and other form tag helpers. You will work with forms frequently and these form helpers will become second nature.

When you use form helper file_field on the form builder shown below

Logo: <%= f.file_field(:logo) %>

it automatically sets

 :multipart => true 

on the form.

Custom helpers

Rails has many built in helper methods. It also makes it easy for us to write our own custom helpers. Helpers are simply Ruby modules with methods to find inside of them. Rails generates a helper file automatically when you generate a controller, or you can create your own. The separate helper files are just a way to keep code organized by topic. The code in all of the helper files is actually available in all of the view templates. Helpers are useful for storing code that you use often and provide an opportunity to move long or complex code out of your views. If you find that you're writing a lot of Ruby code in an HTML template, it may be easier to extract it to a custom helper method. The helpers are going to be in the app helpers directory. We have several in our project already from where we created controllers, but each of them is empty. You can see that it's just a Ruby module. Let's add a custom helper to application helper. We have something here that renders a partial for the error messages at the top of our form. I'm going to take that code right there and I'm just going to copy it, and let's go into application helper, and let's write a new method. I'm going to call it error messages for and I'll pass in an object to it. And then what will it do? Well, it's going to render that partial that's in layout errors with the object and we're not going to use f.object, we're going to use whatever object was passed in. The reason why is just 'cause this looks a little nicer. I'll save it. Let's come back over to the form. Let's paste this in here, but let's pass in f.object as the argument. So now, error messages for will take care of that rendering process for us. I find this to be a little friendlier. I'll copy it, let's go over to our categories form, and let's do the same thing there. So that's one example of how we can use a helper method. Let's come back and create another one. This one, I'm going to call status tag and I'm going to pass in a boolean with it as well as allow it to pass in some options if someone wants. And in here, let's set options for the true text of our status tag to be equal to nothing by default, and we'll set one for the false text so someone can pass in text if they want for each of those. And then we're going to say if the boolean that we're passed in is true, we're going to do one thing, and that is going to be to output a content tag that is a span tag, and we'll provide the text for it which will be whatever the true text is, and then we'll give it a class of status true. And let's take that same thing, let's copy it and paste it down here, but this time, it's going to be for whatever the false text is, and the status false. So the idea here is that we can just pass in a boolean and it will output a span tag in its place, showing whether something is true or false and then we can style it using that true and false. Where I think a great place to use this would be is in our tasks index list. Right now, we have completed and we have it say task completed yes or no. Well instead, we could put status tag around that, and then let's remove the rest of it, and now it will output those span tags that are ready to be styled to show whether this is completed or not. I've actually already added some styles to the project. If we go to the style sheets under structure, scroll down, you'll see I've got style here. I just basically make it 10 pixels by 10 pixels, give it some margin, and then I set a background image whether it's true or false. One of them is solid square check and the other solid square X, and those are images that I've added here and they'll just display an X or a check mark that we can actually take a look at. So once we've got that all in place, let's go look at it, rails server, and let's go into Firefox, let's go to our tasks, look at that. We see Xs instead. Now none of them are completed. Let's say that we complete one, let's edit mow lawn, mark it completed, edit task, let's go back to the list, and now it shows a check mark instead. Hopefully you see how we took a lot of complexity there and just put it into a very simple method. We just call status tag on any boolean and we get back this behavior. Now we know how easy it is to write our own custom helper methods in Ruby on Rails.